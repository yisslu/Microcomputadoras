CCS PCM C Compiler, Version 5.076, 2401               12-Jun-23 13:17

               Filename:   C:\Users\aaldi\OneDrive - UNIVERSIDAD NACIONAL AUTÓNOMA DE MÉXICO\school\8th-semester\Micro-Tareas\ProyectoFinal\PuertoSerial\PuertoSerial.lst

               ROM used:   2704 words (33%)
                           Largest free fragment is 2048
               RAM used:   42 (11%) at main() level
                           157 (43%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  09
0001:  MOVWF  0A
0002:  GOTO   162
0003:  NOP
.................... #include <16f887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0004:  DATA 49,37
0005:  DATA 67,39
0006:  DATA E5,39
0007:  DATA 65,10
0008:  DATA E3,37
0009:  DATA ED,30
000A:  DATA 6E,32
000B:  DATA 6F,1D
000C:  DATA 20,05
000D:  DATA 0D,00
000E:  DATA 54,34
000F:  DATA 65,10
0010:  DATA E7,34
0011:  DATA F6,32
0012:  DATA 6E,10
0013:  DATA 73,3A
0014:  DATA F2,34
0015:  DATA EE,33
0016:  DATA A0,34
0017:  DATA 73,10
0018:  DATA 3A,10
0019:  DATA A5,39
001A:  DATA 8A,06
001B:  DATA 00,00
001C:  DATA 4F,38
001D:  DATA E3,34
001E:  DATA 6F,37
001F:  DATA 3A,10
0020:  DATA 25,32
0021:  DATA 8A,06
0022:  DATA 80,04
0023:  DATA A0,22
0024:  DATA 73,38
0025:  DATA 65,39
0026:  DATA 61,37
0027:  DATA E4,37
0028:  DATA A0,31
0029:  DATA EF,36
002A:  DATA 61,37
002B:  DATA E4,37
002C:  DATA 2E,17
002D:  DATA 2E,00
002E:  DATA 20,2A
002F:  DATA E5,36
0030:  DATA 70,17
0031:  DATA 3A,10
0032:  DATA 25,33
0033:  DATA A0,21
0034:  DATA 00,00
0035:  DATA A0,26
0036:  DATA 6F,3A
0037:  DATA 6F,39
0038:  DATA A0,27
0039:  DATA 4E,00
003A:  DATA A0,26
003B:  DATA 6F,3A
003C:  DATA 6F,39
003D:  DATA A0,27
003E:  DATA 46,23
003F:  DATA 00,01
0040:  DATA 20,26
0041:  DATA 65,32
0042:  DATA 73,10
0043:  DATA 4F,27
0044:  DATA 00,01
0045:  DATA 20,26
0046:  DATA 65,32
0047:  DATA 73,10
0048:  DATA 4F,23
0049:  DATA 46,00
004A:  DATA 20,28
004B:  DATA D7,26
004C:  DATA A0,22
004D:  DATA F8,34
004E:  DATA F4,37
004F:  DATA F3,37
0050:  DATA 21,00
0051:  DATA 55,38
0052:  DATA 73,16
0053:  DATA A0,34
0054:  DATA 6E,3A
0055:  DATA 65,37
0056:  DATA F4,30
0057:  DATA 20,32
0058:  DATA 65,10
0059:  DATA EE,3A
005A:  DATA 65,3B
005B:  DATA 6F,10
005C:  DATA 75,37
005D:  DATA A0,31
005E:  DATA EF,36
005F:  DATA 61,37
0060:  DATA E4,37
0061:  DATA A0,34
0062:  DATA 6E,3B
0063:  DATA 61,36
0064:  DATA 69,32
0065:  DATA 6F,05
0066:  DATA 8D,20
0067:  DATA EC,33
0068:  DATA 75,37
0069:  DATA EF,39
006A:  DATA A0,31
006B:  DATA EF,36
006C:  DATA 61,37
006D:  DATA E4,37
006E:  DATA 73,10
006F:  DATA F6,30
0070:  DATA EC,34
0071:  DATA E4,37
0072:  DATA 73,10
0073:  DATA F3,37
0074:  DATA 6E,1D
0075:  DATA 8A,06
0076:  DATA ED,37
0077:  DATA F4,37
0078:  DATA 72,10
0079:  DATA 6F,37
007A:  DATA 2C,10
007B:  DATA F0,3B
007C:  DATA ED,1E
007D:  DATA 35,18
007E:  DATA 2C,10
007F:  DATA EC,32
0080:  DATA E4,39
0081:  DATA A0,37
0082:  DATA 66,33
0083:  DATA 2C,10
0084:  DATA F4,32
0085:  DATA 6D,38
0086:  DATA 65,39
0087:  DATA 61,3A
0088:  DATA 75,39
0089:  DATA 61,05
008A:  DATA 0D,00
*
0134:  MOVF   0B,W
0135:  MOVWF  4A
0136:  BCF    0B.7
0137:  BSF    03.5
0138:  BSF    03.6
0139:  BSF    0C.7
013A:  BSF    0C.0
013B:  NOP
013C:  NOP
013D:  BCF    03.5
013E:  BCF    03.6
013F:  BTFSC  4A.7
0140:  BSF    0B.7
0141:  BSF    03.6
0142:  MOVF   0C,W
0143:  ANDLW  7F
0144:  BTFSC  03.2
0145:  GOTO   18A
0146:  BCF    03.6
0147:  MOVWF  4A
0148:  BSF    03.6
0149:  MOVF   0D,W
014A:  BCF    03.6
014B:  MOVWF  4B
014C:  BSF    03.6
014D:  MOVF   0F,W
014E:  BCF    03.6
014F:  MOVWF  4C
0150:  MOVF   4A,W
0151:  BTFSS  0C.4
0152:  GOTO   151
0153:  MOVWF  19
0154:  MOVF   4B,W
0155:  BSF    03.6
0156:  MOVWF  0D
0157:  BCF    03.6
0158:  MOVF   4C,W
0159:  BSF    03.6
015A:  MOVWF  0F
015B:  BCF    03.6
015C:  MOVF   0B,W
015D:  MOVWF  4D
015E:  BCF    0B.7
015F:  BSF    03.5
0160:  BSF    03.6
0161:  BSF    0C.7
0162:  BSF    0C.0
0163:  NOP
0164:  NOP
0165:  BCF    03.5
0166:  BCF    03.6
0167:  BTFSC  4D.7
0168:  BSF    0B.7
0169:  BSF    03.6
016A:  RLF    0C,W
016B:  RLF    0E,W
016C:  ANDLW  7F
016D:  BTFSC  03.2
016E:  GOTO   18A
016F:  BCF    03.6
0170:  MOVWF  4A
0171:  BSF    03.6
0172:  MOVF   0D,W
0173:  BCF    03.6
0174:  MOVWF  4B
0175:  BSF    03.6
0176:  MOVF   0F,W
0177:  BCF    03.6
0178:  MOVWF  4C
0179:  MOVF   4A,W
017A:  BTFSS  0C.4
017B:  GOTO   17A
017C:  MOVWF  19
017D:  MOVF   4B,W
017E:  BSF    03.6
017F:  MOVWF  0D
0180:  BCF    03.6
0181:  MOVF   4C,W
0182:  BSF    03.6
0183:  MOVWF  0F
0184:  INCF   0D,F
0185:  BTFSC  03.2
0186:  INCF   0F,F
0187:  BCF    03.6
0188:  GOTO   134
0189:  BSF    03.6
018A:  BCF    03.6
018B:  RETURN
018C:  MOVF   0B,W
018D:  MOVWF  4B
018E:  BCF    0B.7
018F:  BSF    03.5
0190:  BSF    03.6
0191:  BSF    0C.7
0192:  BSF    0C.0
0193:  NOP
0194:  NOP
0195:  BCF    03.5
0196:  BCF    03.6
0197:  BTFSC  4B.7
0198:  BSF    0B.7
0199:  BTFSC  03.0
019A:  GOTO   1C4
019B:  BSF    03.6
019C:  MOVF   0C,W
019D:  ANDLW  7F
019E:  BCF    03.6
019F:  MOVWF  4B
01A0:  BSF    03.6
01A1:  MOVF   0D,W
01A2:  BCF    03.6
01A3:  MOVWF  4C
01A4:  BSF    03.6
01A5:  MOVF   0F,W
01A6:  BCF    03.6
01A7:  MOVWF  4D
01A8:  MOVF   4B,W
01A9:  BTFSS  0C.4
01AA:  GOTO   1A9
01AB:  MOVWF  19
01AC:  MOVF   4C,W
01AD:  BSF    03.6
01AE:  MOVWF  0D
01AF:  BCF    03.6
01B0:  MOVF   4D,W
01B1:  BSF    03.6
01B2:  MOVWF  0F
01B3:  BCF    03.6
01B4:  MOVF   0B,W
01B5:  MOVWF  4E
01B6:  BCF    0B.7
01B7:  BSF    03.5
01B8:  BSF    03.6
01B9:  BSF    0C.7
01BA:  BSF    0C.0
01BB:  NOP
01BC:  NOP
01BD:  BCF    03.5
01BE:  BCF    03.6
01BF:  BTFSC  4E.7
01C0:  BSF    0B.7
01C1:  DECFSZ 4A,F
01C2:  GOTO   1C4
01C3:  GOTO   1E4
01C4:  BSF    03.6
01C5:  RLF    0C,W
01C6:  RLF    0E,W
01C7:  ANDLW  7F
01C8:  BCF    03.6
01C9:  MOVWF  4B
01CA:  BSF    03.6
01CB:  MOVF   0D,W
01CC:  BCF    03.6
01CD:  MOVWF  4C
01CE:  BSF    03.6
01CF:  MOVF   0F,W
01D0:  BCF    03.6
01D1:  MOVWF  4D
01D2:  MOVF   4B,W
01D3:  BTFSS  0C.4
01D4:  GOTO   1D3
01D5:  MOVWF  19
01D6:  MOVF   4C,W
01D7:  BSF    03.6
01D8:  MOVWF  0D
01D9:  BCF    03.6
01DA:  MOVF   4D,W
01DB:  BSF    03.6
01DC:  MOVWF  0F
01DD:  INCF   0D,F
01DE:  BTFSC  03.2
01DF:  INCF   0F,F
01E0:  BCF    03.0
01E1:  BCF    03.6
01E2:  DECFSZ 4A,F
01E3:  GOTO   18C
01E4:  RETURN
*
022A:  MOVF   00,F
022B:  BTFSC  03.2
022C:  GOTO   240
022D:  CLRF   4B
022E:  MOVF   04,W
022F:  MOVWF  4A
0230:  BCF    4B.0
0231:  BTFSC  03.7
0232:  BSF    4B.0
0233:  MOVF   00,W
0234:  BTFSS  0C.4
0235:  GOTO   234
0236:  MOVWF  19
0237:  MOVF   4A,W
0238:  MOVWF  04
0239:  BCF    03.7
023A:  BTFSC  4B.0
023B:  BSF    03.7
023C:  INCF   04,F
023D:  BTFSC  03.2
023E:  INCF   05,F
023F:  GOTO   22A
*
049E:  CLRF   77
049F:  CLRF   78
04A0:  MOVF   5B,W
04A1:  BCF    03.0
04A2:  BTFSC  5C.0
04A3:  ADDWF  77,F
04A4:  RRF    77,F
04A5:  RRF    78,F
04A6:  BTFSC  5C.1
04A7:  ADDWF  77,F
04A8:  RRF    77,F
04A9:  RRF    78,F
04AA:  BTFSC  5C.2
04AB:  ADDWF  77,F
04AC:  RRF    77,F
04AD:  RRF    78,F
04AE:  BTFSC  5C.3
04AF:  ADDWF  77,F
04B0:  RRF    77,F
04B1:  RRF    78,F
04B2:  BTFSC  5C.4
04B3:  ADDWF  77,F
04B4:  RRF    77,F
04B5:  RRF    78,F
04B6:  BTFSC  5C.5
04B7:  ADDWF  77,F
04B8:  RRF    77,F
04B9:  RRF    78,F
04BA:  BTFSC  5C.6
04BB:  ADDWF  77,F
04BC:  RRF    77,F
04BD:  RRF    78,F
04BE:  BTFSC  5C.7
04BF:  ADDWF  77,F
04C0:  RRF    77,F
04C1:  RRF    78,F
*
0552:  MOVF   4C,W
0553:  CLRF   78
0554:  SUBWF  4B,W
0555:  BTFSC  03.0
0556:  GOTO   55A
0557:  MOVF   4B,W
0558:  MOVWF  77
0559:  GOTO   566
055A:  CLRF   77
055B:  MOVLW  08
055C:  MOVWF  4D
055D:  RLF    4B,F
055E:  RLF    77,F
055F:  MOVF   4C,W
0560:  SUBWF  77,W
0561:  BTFSC  03.0
0562:  MOVWF  77
0563:  RLF    78,F
0564:  DECFSZ 4D,F
0565:  GOTO   55D
0566:  RETURN
0567:  MOVLW  20
0568:  BTFSS  46.4
0569:  MOVLW  30
056A:  MOVWF  47
056B:  MOVF   45,W
056C:  MOVWF  77
056D:  BTFSS  45.7
056E:  GOTO   577
056F:  COMF   77,F
0570:  INCF   77,F
0571:  MOVF   77,W
0572:  MOVWF  45
0573:  MOVLW  2D
0574:  MOVWF  47
0575:  BSF    46.7
0576:  BSF    46.0
0577:  MOVF   45,W
0578:  MOVWF  4B
0579:  MOVLW  64
057A:  MOVWF  4C
057B:  CALL   552
057C:  MOVF   77,W
057D:  MOVWF  45
057E:  MOVLW  30
057F:  ADDWF  78,W
0580:  MOVWF  48
0581:  MOVF   45,W
0582:  MOVWF  4B
0583:  MOVLW  0A
0584:  MOVWF  4C
0585:  CALL   552
0586:  MOVLW  30
0587:  ADDWF  77,W
0588:  MOVWF  4A
0589:  MOVLW  30
058A:  ADDWF  78,W
058B:  MOVWF  49
058C:  MOVF   47,W
058D:  MOVWF  77
058E:  MOVLW  30
058F:  SUBWF  48,W
0590:  BTFSC  03.2
0591:  GOTO   596
0592:  BSF    46.1
0593:  BTFSC  46.7
0594:  BSF    46.2
0595:  GOTO   5AA
0596:  MOVF   47,W
0597:  MOVWF  48
0598:  MOVLW  20
0599:  MOVWF  47
059A:  MOVLW  30
059B:  SUBWF  49,W
059C:  BTFSC  03.2
059D:  GOTO   5A2
059E:  BSF    46.0
059F:  BTFSC  46.7
05A0:  BSF    46.1
05A1:  GOTO   5AA
05A2:  BTFSS  03.2
05A3:  BSF    46.0
05A4:  BTFSS  03.2
05A5:  GOTO   5AA
05A6:  MOVF   48,W
05A7:  MOVWF  49
05A8:  MOVLW  20
05A9:  MOVWF  48
05AA:  BTFSC  46.2
05AB:  GOTO   5B1
05AC:  BTFSC  46.1
05AD:  GOTO   5B5
05AE:  BTFSC  46.0
05AF:  GOTO   5B9
05B0:  GOTO   5BD
05B1:  MOVF   47,W
05B2:  BTFSS  0C.4
05B3:  GOTO   5B2
05B4:  MOVWF  19
05B5:  MOVF   48,W
05B6:  BTFSS  0C.4
05B7:  GOTO   5B6
05B8:  MOVWF  19
05B9:  MOVF   49,W
05BA:  BTFSS  0C.4
05BB:  GOTO   5BA
05BC:  MOVWF  19
05BD:  MOVF   4A,W
05BE:  BTFSS  0C.4
05BF:  GOTO   5BE
05C0:  MOVWF  19
05C1:  BSF    0A.3
05C2:  BCF    0A.4
05C3:  GOTO   1F3 (RETURN)
*
0602:  MOVF   0B,W
0603:  MOVWF  45
0604:  BCF    0B.7
0605:  BSF    03.5
0606:  BSF    03.6
0607:  BSF    0C.7
0608:  BSF    0C.0
0609:  NOP
060A:  NOP
060B:  BCF    03.5
060C:  BCF    03.6
060D:  BTFSC  45.7
060E:  BSF    0B.7
060F:  BSF    03.6
0610:  MOVF   0C,W
0611:  ANDLW  7F
0612:  BTFSC  03.2
0613:  GOTO   656
0614:  BCF    03.6
0615:  MOVWF  45
0616:  BSF    03.6
0617:  MOVF   0D,W
0618:  BCF    03.6
0619:  MOVWF  46
061A:  BSF    03.6
061B:  MOVF   0F,W
061C:  BCF    03.6
061D:  MOVWF  47
061E:  MOVF   45,W
061F:  MOVWF  52
0620:  CALL   5D6
0621:  MOVF   46,W
0622:  BSF    03.6
0623:  MOVWF  0D
0624:  BCF    03.6
0625:  MOVF   47,W
0626:  BSF    03.6
0627:  MOVWF  0F
0628:  BCF    03.6
0629:  MOVF   0B,W
062A:  MOVWF  48
062B:  BCF    0B.7
062C:  BSF    03.5
062D:  BSF    03.6
062E:  BSF    0C.7
062F:  BSF    0C.0
0630:  NOP
0631:  NOP
0632:  BCF    03.5
0633:  BCF    03.6
0634:  BTFSC  48.7
0635:  BSF    0B.7
0636:  BSF    03.6
0637:  RLF    0C,W
0638:  RLF    0E,W
0639:  ANDLW  7F
063A:  BTFSC  03.2
063B:  GOTO   656
063C:  BCF    03.6
063D:  MOVWF  45
063E:  BSF    03.6
063F:  MOVF   0D,W
0640:  BCF    03.6
0641:  MOVWF  46
0642:  BSF    03.6
0643:  MOVF   0F,W
0644:  BCF    03.6
0645:  MOVWF  47
0646:  MOVF   45,W
0647:  MOVWF  52
0648:  CALL   5D6
0649:  MOVF   46,W
064A:  BSF    03.6
064B:  MOVWF  0D
064C:  BCF    03.6
064D:  MOVF   47,W
064E:  BSF    03.6
064F:  MOVWF  0F
0650:  INCF   0D,F
0651:  BTFSC  03.2
0652:  INCF   0F,F
0653:  BCF    03.6
0654:  GOTO   602
0655:  BSF    03.6
0656:  BCF    03.6
0657:  RETURN
*
0668:  MOVLW  8E
0669:  MOVWF  77
066A:  MOVF   46,W
066B:  MOVWF  78
066C:  MOVF   45,W
066D:  MOVWF  79
066E:  CLRF   7A
066F:  MOVF   78,F
0670:  BTFSS  03.2
0671:  GOTO   67C
0672:  MOVF   79,W
0673:  MOVWF  78
0674:  CLRF   79
0675:  MOVLW  08
0676:  SUBWF  77,F
0677:  MOVF   78,F
0678:  BTFSS  03.2
0679:  GOTO   67C
067A:  CLRF   77
067B:  GOTO   684
067C:  BCF    03.0
067D:  BTFSC  78.7
067E:  GOTO   683
067F:  RLF    79,F
0680:  RLF    78,F
0681:  DECF   77,F
0682:  GOTO   67C
0683:  BCF    78.7
*
068F:  MOVF   0B,W
0690:  MOVWF  46
0691:  BCF    0B.7
0692:  BSF    03.5
0693:  BSF    03.6
0694:  BSF    0C.7
0695:  BSF    0C.0
0696:  NOP
0697:  NOP
0698:  BCF    03.5
0699:  BCF    03.6
069A:  BTFSC  46.7
069B:  BSF    0B.7
069C:  BTFSC  03.0
069D:  GOTO   6C6
069E:  BSF    03.6
069F:  MOVF   0C,W
06A0:  ANDLW  7F
06A1:  BCF    03.6
06A2:  MOVWF  46
06A3:  BSF    03.6
06A4:  MOVF   0D,W
06A5:  BCF    03.6
06A6:  MOVWF  47
06A7:  BSF    03.6
06A8:  MOVF   0F,W
06A9:  BCF    03.6
06AA:  MOVWF  48
06AB:  MOVF   46,W
06AC:  MOVWF  52
06AD:  CALL   5D6
06AE:  MOVF   47,W
06AF:  BSF    03.6
06B0:  MOVWF  0D
06B1:  BCF    03.6
06B2:  MOVF   48,W
06B3:  BSF    03.6
06B4:  MOVWF  0F
06B5:  BCF    03.6
06B6:  MOVF   0B,W
06B7:  MOVWF  49
06B8:  BCF    0B.7
06B9:  BSF    03.5
06BA:  BSF    03.6
06BB:  BSF    0C.7
06BC:  BSF    0C.0
06BD:  NOP
06BE:  NOP
06BF:  BCF    03.5
06C0:  BCF    03.6
06C1:  BTFSC  49.7
06C2:  BSF    0B.7
06C3:  DECFSZ 45,F
06C4:  GOTO   6C6
06C5:  GOTO   6E5
06C6:  BSF    03.6
06C7:  RLF    0C,W
06C8:  RLF    0E,W
06C9:  ANDLW  7F
06CA:  BCF    03.6
06CB:  MOVWF  46
06CC:  BSF    03.6
06CD:  MOVF   0D,W
06CE:  BCF    03.6
06CF:  MOVWF  47
06D0:  BSF    03.6
06D1:  MOVF   0F,W
06D2:  BCF    03.6
06D3:  MOVWF  48
06D4:  MOVF   46,W
06D5:  MOVWF  52
06D6:  CALL   5D6
06D7:  MOVF   47,W
06D8:  BSF    03.6
06D9:  MOVWF  0D
06DA:  BCF    03.6
06DB:  MOVF   48,W
06DC:  BSF    03.6
06DD:  MOVWF  0F
06DE:  INCF   0D,F
06DF:  BTFSC  03.2
06E0:  INCF   0F,F
06E1:  BCF    03.0
06E2:  BCF    03.6
06E3:  DECFSZ 45,F
06E4:  GOTO   68F
06E5:  BSF    0A.3
06E6:  BCF    0A.4
06E7:  GOTO   240 (RETURN)
06E8:  BTFSC  03.1
06E9:  GOTO   6ED
06EA:  MOVLW  5A
06EB:  MOVWF  04
06EC:  BCF    03.7
06ED:  CLRF   77
06EE:  CLRF   78
06EF:  CLRF   79
06F0:  CLRF   7A
06F1:  CLRF   5A
06F2:  CLRF   5B
06F3:  CLRF   5C
06F4:  CLRF   5D
06F5:  MOVF   59,W
06F6:  IORWF  58,W
06F7:  IORWF  57,W
06F8:  IORWF  56,W
06F9:  BTFSC  03.2
06FA:  GOTO   72B
06FB:  MOVLW  20
06FC:  MOVWF  5E
06FD:  BCF    03.0
06FE:  RLF    52,F
06FF:  RLF    53,F
0700:  RLF    54,F
0701:  RLF    55,F
0702:  RLF    5A,F
0703:  RLF    5B,F
0704:  RLF    5C,F
0705:  RLF    5D,F
0706:  MOVF   59,W
0707:  SUBWF  5D,W
0708:  BTFSS  03.2
0709:  GOTO   714
070A:  MOVF   58,W
070B:  SUBWF  5C,W
070C:  BTFSS  03.2
070D:  GOTO   714
070E:  MOVF   57,W
070F:  SUBWF  5B,W
0710:  BTFSS  03.2
0711:  GOTO   714
0712:  MOVF   56,W
0713:  SUBWF  5A,W
0714:  BTFSS  03.0
0715:  GOTO   725
0716:  MOVF   56,W
0717:  SUBWF  5A,F
0718:  MOVF   57,W
0719:  BTFSS  03.0
071A:  INCFSZ 57,W
071B:  SUBWF  5B,F
071C:  MOVF   58,W
071D:  BTFSS  03.0
071E:  INCFSZ 58,W
071F:  SUBWF  5C,F
0720:  MOVF   59,W
0721:  BTFSS  03.0
0722:  INCFSZ 59,W
0723:  SUBWF  5D,F
0724:  BSF    03.0
0725:  RLF    77,F
0726:  RLF    78,F
0727:  RLF    79,F
0728:  RLF    7A,F
0729:  DECFSZ 5E,F
072A:  GOTO   6FD
072B:  MOVF   5A,W
072C:  MOVWF  00
072D:  INCF   04,F
072E:  MOVF   5B,W
072F:  MOVWF  00
0730:  INCF   04,F
0731:  MOVF   5C,W
0732:  MOVWF  00
0733:  INCF   04,F
0734:  MOVF   5D,W
0735:  MOVWF  00
0736:  RETURN
*
0763:  CLRF   78
0764:  CLRF   79
0765:  CLRF   77
0766:  CLRF   7A
0767:  MOVF   4C,W
0768:  BTFSS  03.2
0769:  GOTO   76D
076A:  MOVF   4B,W
076B:  BTFSC  03.2
076C:  GOTO   787
076D:  MOVLW  10
076E:  MOVWF  4D
076F:  BCF    03.0
0770:  RLF    49,F
0771:  RLF    4A,F
0772:  RLF    77,F
0773:  RLF    7A,F
0774:  MOVF   4C,W
0775:  SUBWF  7A,W
0776:  BTFSS  03.2
0777:  GOTO   77A
0778:  MOVF   4B,W
0779:  SUBWF  77,W
077A:  BTFSS  03.0
077B:  GOTO   783
077C:  MOVF   4B,W
077D:  SUBWF  77,F
077E:  BTFSS  03.0
077F:  DECF   7A,F
0780:  MOVF   4C,W
0781:  SUBWF  7A,F
0782:  BSF    03.0
0783:  RLF    78,F
0784:  RLF    79,F
0785:  DECFSZ 4D,F
0786:  GOTO   76F
*
0800:  MOVF   04,W
0801:  MOVWF  4A
0802:  MOVF   49,W
0803:  MOVWF  4C
0804:  BTFSC  03.2
0805:  GOTO   093
0806:  MOVF   48,W
0807:  MOVWF  55
0808:  MOVF   47,W
0809:  MOVWF  54
080A:  MOVF   46,W
080B:  MOVWF  53
080C:  MOVF   45,W
080D:  MOVWF  52
080E:  CLRF   59
080F:  CLRF   58
0810:  MOVLW  20
0811:  MOVWF  57
0812:  MOVLW  82
0813:  MOVWF  56
0814:  MOVF   52,W
0815:  BTFSC  03.2
0816:  GOTO   085
0817:  MOVWF  5A
0818:  MOVF   56,W
0819:  BTFSC  03.2
081A:  GOTO   085
081B:  ADDWF  5A,F
081C:  BTFSS  03.0
081D:  GOTO   01F
081E:  GOTO   026
081F:  MOVLW  7F
0820:  SUBWF  5A,F
0821:  BTFSS  03.0
0822:  GOTO   085
0823:  BTFSC  03.2
0824:  GOTO   085
0825:  GOTO   02A
0826:  MOVLW  81
0827:  ADDWF  5A,F
0828:  BTFSC  03.0
0829:  GOTO   085
082A:  MOVF   5A,W
082B:  MOVWF  77
082C:  CLRF   78
082D:  CLRF   79
082E:  CLRF   7A
082F:  MOVF   53,W
0830:  MOVWF  5E
0831:  BSF    5E.7
0832:  MOVF   54,W
0833:  MOVWF  5D
0834:  MOVF   55,W
0835:  MOVWF  5C
0836:  MOVLW  18
0837:  MOVWF  5A
0838:  CLRF   5B
0839:  BTFSS  5C.0
083A:  GOTO   053
083B:  MOVF   59,W
083C:  ADDWF  7A,F
083D:  BTFSS  03.0
083E:  GOTO   045
083F:  INCF   79,F
0840:  BTFSS  03.2
0841:  GOTO   045
0842:  INCF   78,F
0843:  BTFSC  03.2
0844:  BSF    5B.7
0845:  MOVF   58,W
0846:  ADDWF  79,F
0847:  BTFSS  03.0
0848:  GOTO   04C
0849:  INCF   78,F
084A:  BTFSC  03.2
084B:  BSF    5B.7
084C:  MOVF   57,W
084D:  MOVWF  54
084E:  BSF    54.7
084F:  MOVF   54,W
0850:  ADDWF  78,F
0851:  BTFSC  03.0
0852:  BSF    5B.7
0853:  RLF    5B,F
0854:  RRF    78,F
0855:  RRF    79,F
0856:  RRF    7A,F
0857:  RRF    5E,F
0858:  RRF    5D,F
0859:  RRF    5C,F
085A:  BCF    03.0
085B:  DECFSZ 5A,F
085C:  GOTO   038
085D:  MOVLW  01
085E:  ADDWF  77,F
085F:  BTFSC  03.0
0860:  GOTO   085
0861:  BTFSC  78.7
0862:  GOTO   06A
0863:  RLF    5E,F
0864:  RLF    7A,F
0865:  RLF    79,F
0866:  RLF    78,F
0867:  DECF   77,F
0868:  BTFSC  03.2
0869:  GOTO   085
086A:  BTFSS  5E.7
086B:  GOTO   07B
086C:  INCF   7A,F
086D:  BTFSS  03.2
086E:  GOTO   07B
086F:  INCF   79,F
0870:  BTFSS  03.2
0871:  GOTO   07B
0872:  INCF   78,F
0873:  BTFSS  03.2
0874:  GOTO   07B
0875:  RRF    78,F
0876:  RRF    79,F
0877:  RRF    7A,F
0878:  INCF   77,F
0879:  BTFSC  03.2
087A:  GOTO   085
087B:  MOVF   53,W
087C:  MOVWF  5B
087D:  MOVF   57,W
087E:  XORWF  5B,F
087F:  BTFSS  5B.7
0880:  GOTO   083
0881:  BSF    78.7
0882:  GOTO   089
0883:  BCF    78.7
0884:  GOTO   089
0885:  CLRF   77
0886:  CLRF   78
0887:  CLRF   79
0888:  CLRF   7A
0889:  MOVF   7A,W
088A:  MOVWF  48
088B:  MOVF   79,W
088C:  MOVWF  47
088D:  MOVF   78,W
088E:  MOVWF  46
088F:  MOVF   77,W
0890:  MOVWF  45
0891:  DECFSZ 4C,F
0892:  GOTO   006
0893:  MOVF   48,W
0894:  MOVWF  55
0895:  MOVF   47,W
0896:  MOVWF  54
0897:  MOVF   46,W
0898:  MOVWF  53
0899:  MOVF   45,W
089A:  MOVWF  52
089B:  MOVF   52,W
089C:  SUBLW  B6
089D:  MOVWF  52
089E:  CLRF   7A
089F:  MOVF   53,W
08A0:  MOVWF  56
08A1:  BSF    53.7
08A2:  BCF    03.0
08A3:  RRF    53,F
08A4:  RRF    54,F
08A5:  RRF    55,F
08A6:  RRF    7A,F
08A7:  RRF    79,F
08A8:  RRF    78,F
08A9:  RRF    77,F
08AA:  DECFSZ 52,F
08AB:  GOTO   0A2
08AC:  BTFSS  56.7
08AD:  GOTO   0B9
08AE:  COMF   77,F
08AF:  COMF   78,F
08B0:  COMF   79,F
08B1:  COMF   7A,F
08B2:  INCF   77,F
08B3:  BTFSC  03.2
08B4:  INCF   78,F
08B5:  BTFSC  03.2
08B6:  INCF   79,F
08B7:  BTFSC  03.2
08B8:  INCF   7A,F
08B9:  MOVF   7A,W
08BA:  MOVWF  48
08BB:  MOVF   79,W
08BC:  MOVWF  47
08BD:  MOVF   78,W
08BE:  MOVWF  46
08BF:  MOVF   77,W
08C0:  MOVWF  45
08C1:  BTFSS  48.7
08C2:  GOTO   0D0
08C3:  DECF   4A,F
08C4:  BSF    4A.5
08C5:  COMF   45,F
08C6:  COMF   46,F
08C7:  COMF   47,F
08C8:  COMF   48,F
08C9:  INCF   45,F
08CA:  BTFSC  03.2
08CB:  INCF   46,F
08CC:  BTFSC  03.2
08CD:  INCF   47,F
08CE:  BTFSC  03.2
08CF:  INCF   48,F
08D0:  MOVLW  3B
08D1:  MOVWF  51
08D2:  MOVLW  9A
08D3:  MOVWF  50
08D4:  MOVLW  CA
08D5:  MOVWF  4F
08D6:  CLRF   4E
08D7:  MOVLW  0A
08D8:  MOVWF  4C
08D9:  MOVF   49,W
08DA:  BTFSC  03.2
08DB:  INCF   4A,F
08DC:  BSF    03.1
08DD:  MOVLW  45
08DE:  MOVWF  04
08DF:  BCF    03.7
08E0:  MOVF   48,W
08E1:  MOVWF  55
08E2:  MOVF   47,W
08E3:  MOVWF  54
08E4:  MOVF   46,W
08E5:  MOVWF  53
08E6:  MOVF   45,W
08E7:  MOVWF  52
08E8:  MOVF   51,W
08E9:  MOVWF  59
08EA:  MOVF   50,W
08EB:  MOVWF  58
08EC:  MOVF   4F,W
08ED:  MOVWF  57
08EE:  MOVF   4E,W
08EF:  MOVWF  56
08F0:  BCF    0A.3
08F1:  CALL   6E8
08F2:  BSF    0A.3
08F3:  MOVF   78,W
08F4:  MOVF   77,F
08F5:  BTFSS  03.2
08F6:  GOTO   10A
08F7:  INCF   49,W
08F8:  SUBWF  4C,W
08F9:  BTFSC  03.2
08FA:  GOTO   10A
08FB:  MOVF   4A,W
08FC:  BTFSC  03.2
08FD:  GOTO   10C
08FE:  ANDLW  0F
08FF:  SUBWF  4C,W
0900:  BTFSC  03.2
0901:  GOTO   104
0902:  BTFSC  03.0
0903:  GOTO   144
0904:  BTFSC  4A.7
0905:  GOTO   144
0906:  BTFSC  4A.6
0907:  GOTO   10C
0908:  MOVLW  20
0909:  GOTO   13E
090A:  MOVLW  20
090B:  ANDWF  4A,F
090C:  BTFSS  4A.5
090D:  GOTO   11C
090E:  BCF    4A.5
090F:  MOVF   49,W
0910:  BTFSS  03.2
0911:  DECF   4A,F
0912:  MOVF   77,W
0913:  MOVWF  4A
0914:  MOVLW  2D
0915:  MOVWF  52
0916:  BCF    0A.3
0917:  CALL   5D6
0918:  BSF    0A.3
0919:  MOVF   4A,W
091A:  MOVWF  77
091B:  CLRF   4A
091C:  MOVF   49,W
091D:  SUBWF  4C,W
091E:  BTFSS  03.2
091F:  GOTO   12C
0920:  MOVF   77,W
0921:  MOVWF  4A
0922:  MOVLW  2E
0923:  MOVWF  52
0924:  BCF    0A.3
0925:  CALL   5D6
0926:  BSF    0A.3
0927:  MOVF   4A,W
0928:  MOVWF  77
0929:  MOVLW  20
092A:  ANDWF  4A,F
092B:  MOVLW  00
092C:  MOVLW  30
092D:  BTFSS  4A.5
092E:  GOTO   13E
092F:  BCF    4A.5
0930:  MOVF   49,W
0931:  BTFSS  03.2
0932:  DECF   4A,F
0933:  MOVF   77,W
0934:  MOVWF  4A
0935:  MOVLW  2D
0936:  MOVWF  52
0937:  BCF    0A.3
0938:  CALL   5D6
0939:  BSF    0A.3
093A:  MOVF   4A,W
093B:  MOVWF  77
093C:  CLRF   4A
093D:  MOVLW  30
093E:  ADDWF  77,F
093F:  MOVF   77,W
0940:  MOVWF  52
0941:  BCF    0A.3
0942:  CALL   5D6
0943:  BSF    0A.3
0944:  BCF    03.1
0945:  MOVF   51,W
0946:  MOVWF  55
0947:  MOVF   50,W
0948:  MOVWF  54
0949:  MOVF   4F,W
094A:  MOVWF  53
094B:  MOVF   4E,W
094C:  MOVWF  52
094D:  CLRF   59
094E:  CLRF   58
094F:  CLRF   57
0950:  MOVLW  0A
0951:  MOVWF  56
0952:  BCF    0A.3
0953:  CALL   6E8
0954:  BSF    0A.3
0955:  MOVF   7A,W
0956:  MOVWF  51
0957:  MOVF   79,W
0958:  MOVWF  50
0959:  MOVF   78,W
095A:  MOVWF  4F
095B:  MOVF   77,W
095C:  MOVWF  4E
095D:  DECFSZ 4C,F
095E:  GOTO   0DC
095F:  BSF    0A.3
0960:  BCF    0A.4
0961:  GOTO   24E (RETURN)
....................  
.................... #list 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
*
0758:  CLRF   7A
0759:  MOVF   45,W
075A:  MOVWF  48
075B:  CLRF   47
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
03D0:  MOVF   50,W
03D1:  MOVWF  7A
03D2:  MOVF   4F,W
03D3:  MOVWF  04
03D4:  BCF    03.7
03D5:  BTFSC  7A.0
03D6:  BSF    03.7
03D7:  MOVF   00,F
03D8:  BTFSC  03.2
03D9:  GOTO   41A
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
03DA:  MOVF   50,W
03DB:  MOVWF  54
03DC:  MOVF   4F,W
03DD:  MOVWF  53
03DE:  MOVF   52,W
03DF:  MOVWF  56
03E0:  MOVF   51,W
03E1:  MOVWF  55
03E2:  MOVF   56,W
03E3:  MOVWF  7A
03E4:  MOVF   55,W
03E5:  MOVWF  04
03E6:  BCF    03.7
03E7:  BTFSC  7A.0
03E8:  BSF    03.7
03E9:  MOVF   00,F
03EA:  BTFSC  03.2
03EB:  GOTO   407
03EC:  MOVF   54,W
03ED:  MOVWF  7A
03EE:  MOVF   53,W
03EF:  MOVWF  04
03F0:  BCF    03.7
03F1:  BTFSC  7A.0
03F2:  BSF    03.7
03F3:  MOVF   00,W
03F4:  MOVWF  57
03F5:  MOVF   56,W
03F6:  MOVWF  7A
03F7:  MOVF   55,W
03F8:  MOVWF  04
03F9:  BCF    03.7
03FA:  BTFSC  7A.0
03FB:  BSF    03.7
03FC:  MOVF   00,W
03FD:  SUBWF  57,W
03FE:  BTFSS  03.2
03FF:  GOTO   407
0400:  INCF   53,F
0401:  BTFSC  03.2
0402:  INCF   54,F
0403:  INCF   55,F
0404:  BTFSC  03.2
0405:  INCF   56,F
0406:  GOTO   3E2
....................  
....................       if (*t == '\0') 
0407:  MOVF   56,W
0408:  MOVWF  7A
0409:  MOVF   55,W
040A:  MOVWF  04
040B:  BCF    03.7
040C:  BTFSC  7A.0
040D:  BSF    03.7
040E:  MOVF   00,F
040F:  BTFSS  03.2
0410:  GOTO   416
....................          return s1; 
0411:  MOVF   4F,W
0412:  MOVWF  78
0413:  MOVF   50,W
0414:  MOVWF  79
0415:  GOTO   41D
....................       ++s1; 
0416:  INCF   4F,F
0417:  BTFSC  03.2
0418:  INCF   50,F
....................       #ifdef FASTER_BUT_MORE_ROM 
0419:  GOTO   3D0
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
041A:  MOVLW  00
041B:  MOVWF  78
041C:  MOVWF  79
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
099F:  BCF    03.6
09A0:  CLRF   20
09A1:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0430:  CLRF   59
....................    sign = 0; 
0431:  CLRF   57
....................    base = 10; 
0432:  MOVLW  0A
0433:  MOVWF  58
....................    result = 0; 
0434:  CLRF   56
....................  
....................    if (!s) 
0435:  MOVF   54,W
0436:  IORWF  55,W
0437:  BTFSS  03.2
0438:  GOTO   43C
....................       return 0; 
0439:  MOVLW  00
043A:  MOVWF  78
043B:  GOTO   52F
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
043C:  MOVF   59,W
043D:  INCF   59,F
043E:  ADDWF  54,W
043F:  MOVWF  04
0440:  BCF    03.7
0441:  BTFSC  55.0
0442:  BSF    03.7
0443:  MOVF   00,W
0444:  MOVWF  5A
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0445:  MOVF   5A,W
0446:  SUBLW  2D
0447:  BTFSS  03.2
0448:  GOTO   455
....................    { 
....................       sign = 1;         // Set the sign to negative 
0449:  MOVLW  01
044A:  MOVWF  57
....................       c = s[index++]; 
044B:  MOVF   59,W
044C:  INCF   59,F
044D:  ADDWF  54,W
044E:  MOVWF  04
044F:  BCF    03.7
0450:  BTFSC  55.0
0451:  BSF    03.7
0452:  MOVF   00,W
0453:  MOVWF  5A
....................    } 
0454:  GOTO   462
....................    else if (c == '+') 
0455:  MOVF   5A,W
0456:  SUBLW  2B
0457:  BTFSS  03.2
0458:  GOTO   462
....................    { 
....................       c = s[index++]; 
0459:  MOVF   59,W
045A:  INCF   59,F
045B:  ADDWF  54,W
045C:  MOVWF  04
045D:  BCF    03.7
045E:  BTFSC  55.0
045F:  BSF    03.7
0460:  MOVF   00,W
0461:  MOVWF  5A
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0462:  MOVF   5A,W
0463:  SUBLW  2F
0464:  BTFSC  03.0
0465:  GOTO   525
0466:  MOVF   5A,W
0467:  SUBLW  39
0468:  BTFSS  03.0
0469:  GOTO   525
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
046A:  MOVF   5A,W
046B:  SUBLW  30
046C:  BTFSS  03.2
046D:  GOTO   48E
046E:  MOVF   59,W
046F:  ADDWF  54,W
0470:  MOVWF  04
0471:  BCF    03.7
0472:  BTFSC  55.0
0473:  BSF    03.7
0474:  MOVF   00,W
0475:  SUBLW  78
0476:  BTFSC  03.2
0477:  GOTO   482
0478:  MOVF   59,W
0479:  ADDWF  54,W
047A:  MOVWF  04
047B:  BCF    03.7
047C:  BTFSC  55.0
047D:  BSF    03.7
047E:  MOVF   00,W
047F:  SUBLW  58
0480:  BTFSS  03.2
0481:  GOTO   48E
....................       { 
....................          base = 16; 
0482:  MOVLW  10
0483:  MOVWF  58
....................          index++; 
0484:  INCF   59,F
....................          c = s[index++]; 
0485:  MOVF   59,W
0486:  INCF   59,F
0487:  ADDWF  54,W
0488:  MOVWF  04
0489:  BCF    03.7
048A:  BTFSC  55.0
048B:  BSF    03.7
048C:  MOVF   00,W
048D:  MOVWF  5A
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
048E:  MOVF   58,W
048F:  SUBLW  0A
0490:  BTFSS  03.2
0491:  GOTO   4D3
....................       { 
....................          while (c >= '0' && c <= '9') 
0492:  MOVF   5A,W
0493:  SUBLW  2F
0494:  BTFSC  03.0
0495:  GOTO   4D2
0496:  MOVF   5A,W
0497:  SUBLW  39
0498:  BTFSS  03.0
0499:  GOTO   4D2
....................          { 
....................             result = 10*result + (c - '0'); 
049A:  MOVLW  0A
049B:  MOVWF  5B
049C:  MOVF   56,W
049D:  MOVWF  5C
*
04C2:  MOVF   78,W
04C3:  MOVWF  5B
04C4:  MOVLW  30
04C5:  SUBWF  5A,W
04C6:  ADDWF  5B,W
04C7:  MOVWF  56
....................             c = s[index++]; 
04C8:  MOVF   59,W
04C9:  INCF   59,F
04CA:  ADDWF  54,W
04CB:  MOVWF  04
04CC:  BCF    03.7
04CD:  BTFSC  55.0
04CE:  BSF    03.7
04CF:  MOVF   00,W
04D0:  MOVWF  5A
04D1:  GOTO   492
....................          } 
....................       } 
04D2:  GOTO   525
....................       else if (base == 16)    // The number is a hexa number 
04D3:  MOVF   58,W
04D4:  SUBLW  10
04D5:  BTFSS  03.2
04D6:  GOTO   525
....................       { 
....................          c = toupper(c); 
04D7:  MOVF   5A,W
04D8:  SUBLW  60
04D9:  BTFSC  03.0
04DA:  GOTO   4E2
04DB:  MOVF   5A,W
04DC:  SUBLW  7A
04DD:  BTFSS  03.0
04DE:  GOTO   4E2
04DF:  MOVF   5A,W
04E0:  ANDLW  DF
04E1:  GOTO   4E3
04E2:  MOVF   5A,W
04E3:  MOVWF  5A
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
04E4:  MOVF   5A,W
04E5:  SUBLW  2F
04E6:  BTFSC  03.0
04E7:  GOTO   4EC
04E8:  MOVF   5A,W
04E9:  SUBLW  39
04EA:  BTFSC  03.0
04EB:  GOTO   4F4
04EC:  MOVF   5A,W
04ED:  SUBLW  40
04EE:  BTFSC  03.0
04EF:  GOTO   525
04F0:  MOVF   5A,W
04F1:  SUBLW  46
04F2:  BTFSS  03.0
04F3:  GOTO   525
....................          { 
....................             if (c >= '0' && c <= '9') 
04F4:  MOVF   5A,W
04F5:  SUBLW  2F
04F6:  BTFSC  03.0
04F7:  GOTO   505
04F8:  MOVF   5A,W
04F9:  SUBLW  39
04FA:  BTFSS  03.0
04FB:  GOTO   505
....................                result = (result << 4) + (c - '0'); 
04FC:  SWAPF  56,W
04FD:  MOVWF  5B
04FE:  MOVLW  F0
04FF:  ANDWF  5B,F
0500:  MOVLW  30
0501:  SUBWF  5A,W
0502:  ADDWF  5B,W
0503:  MOVWF  56
0504:  GOTO   50E
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0505:  SWAPF  56,W
0506:  MOVWF  5B
0507:  MOVLW  F0
0508:  ANDWF  5B,F
0509:  MOVLW  41
050A:  SUBWF  5A,W
050B:  ADDLW  0A
050C:  ADDWF  5B,W
050D:  MOVWF  56
....................  
....................             c = s[index++]; 
050E:  MOVF   59,W
050F:  INCF   59,F
0510:  ADDWF  54,W
0511:  MOVWF  04
0512:  BCF    03.7
0513:  BTFSC  55.0
0514:  BSF    03.7
0515:  MOVF   00,W
0516:  MOVWF  5A
....................             c = toupper(c); 
0517:  MOVF   5A,W
0518:  SUBLW  60
0519:  BTFSC  03.0
051A:  GOTO   522
051B:  MOVF   5A,W
051C:  SUBLW  7A
051D:  BTFSS  03.0
051E:  GOTO   522
051F:  MOVF   5A,W
0520:  ANDLW  DF
0521:  GOTO   523
0522:  MOVF   5A,W
0523:  MOVWF  5A
0524:  GOTO   4E4
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0525:  DECFSZ 57,W
0526:  GOTO   52D
0527:  MOVF   58,W
0528:  SUBLW  0A
0529:  BTFSS  03.2
052A:  GOTO   52D
....................        result = -result; 
052B:  COMF   56,F
052C:  INCF   56,F
....................  
....................    return(result); 
052D:  MOVF   56,W
052E:  MOVWF  78
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #fuses HS, NOWDT, NOPROTECT, NOLVP 
.................... #use delay(clock = 20M) 
*
008B:  MOVLW  53
008C:  MOVWF  04
008D:  BCF    03.7
008E:  MOVF   00,W
008F:  BTFSC  03.2
0090:  GOTO   09E
0091:  MOVLW  06
0092:  MOVWF  78
0093:  CLRF   77
0094:  DECFSZ 77,F
0095:  GOTO   094
0096:  DECFSZ 78,F
0097:  GOTO   093
0098:  MOVLW  7B
0099:  MOVWF  77
009A:  DECFSZ 77,F
009B:  GOTO   09A
009C:  DECFSZ 00,F
009D:  GOTO   091
009E:  RETURN
.................... #use rs232(baud = 9600, xmit = PIN_C6, rcv = PIN_C7) 
.................... #use i2c(MASTER, SDA = PIN_C4, SCL = PIN_C3, SLOW, NOFORCE_SW) 
.................... // #include "i2c-lcd.c" 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
00BA:  MOVLW  0F
00BB:  BSF    03.5
00BC:  ANDWF  08,W
00BD:  IORLW  F0
00BE:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00BF:  BCF    03.5
00C0:  BSF    08.2
....................    delay_cycles(1); 
00C1:  NOP
....................    lcd_output_enable(1); 
00C2:  BSF    08.0
....................    delay_cycles(1); 
00C3:  NOP
....................    high = lcd_read_nibble(); 
00C4:  CALL   0AE
00C5:  MOVF   78,W
00C6:  MOVWF  5A
....................        
....................    lcd_output_enable(0); 
00C7:  BCF    08.0
....................    delay_cycles(1); 
00C8:  NOP
....................    lcd_output_enable(1); 
00C9:  BSF    08.0
....................    delay_us(1); 
00CA:  GOTO   0CB
00CB:  GOTO   0CC
00CC:  NOP
....................    low = lcd_read_nibble(); 
00CD:  CALL   0AE
00CE:  MOVF   78,W
00CF:  MOVWF  59
....................        
....................    lcd_output_enable(0); 
00D0:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00D1:  MOVLW  0F
00D2:  BSF    03.5
00D3:  ANDWF  08,W
00D4:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00D5:  BCF    03.5
00D6:  SWAPF  5A,W
00D7:  MOVWF  77
00D8:  MOVLW  F0
00D9:  ANDWF  77,F
00DA:  MOVF   77,W
00DB:  IORWF  59,W
00DC:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
00AE:  MOVF   08,W
00AF:  MOVWF  77
00B0:  SWAPF  08,W
00B1:  ANDLW  0F
00B2:  MOVWF  78
....................   #endif 
00B3:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
009F:  SWAPF  5A,W
00A0:  ANDLW  F0
00A1:  MOVWF  77
00A2:  MOVLW  0F
00A3:  ANDWF  08,W
00A4:  IORWF  77,W
00A5:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
00A6:  NOP
....................    lcd_output_enable(1); 
00A7:  BSF    08.0
....................    delay_us(2); 
00A8:  MOVLW  03
00A9:  MOVWF  77
00AA:  DECFSZ 77,F
00AB:  GOTO   0AA
....................    lcd_output_enable(0); 
00AC:  BCF    08.0
00AD:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00B4:  BSF    03.5
00B5:  BCF    08.0
....................    lcd_rs_tris(); 
00B6:  BCF    08.1
....................    lcd_rw_tris(); 
00B7:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00B8:  BCF    03.5
00B9:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
00DD:  MOVF   78,W
00DE:  MOVWF  59
00DF:  BTFSC  59.7
00E0:  GOTO   0BA
....................    lcd_output_rs(address); 
00E1:  BTFSS  57.0
00E2:  BCF    08.1
00E3:  BTFSC  57.0
00E4:  BSF    08.1
....................    delay_cycles(1); 
00E5:  NOP
....................    lcd_output_rw(0); 
00E6:  BCF    08.2
....................    delay_cycles(1); 
00E7:  NOP
....................    lcd_output_enable(0); 
00E8:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
00E9:  SWAPF  58,W
00EA:  MOVWF  59
00EB:  MOVLW  0F
00EC:  ANDWF  59,F
00ED:  MOVF   59,W
00EE:  MOVWF  5A
00EF:  CALL   09F
....................    lcd_send_nibble(n & 0xf); 
00F0:  MOVF   58,W
00F1:  ANDLW  0F
00F2:  MOVWF  59
00F3:  MOVWF  5A
00F4:  CALL   09F
00F5:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
00F6:  MOVLW  28
00F7:  MOVWF  46
00F8:  MOVLW  0C
00F9:  MOVWF  47
00FA:  MOVLW  01
00FB:  MOVWF  48
00FC:  MOVLW  06
00FD:  MOVWF  49
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
00FE:  BCF    08.0
....................    lcd_output_rs(0); 
00FF:  BCF    08.1
....................    lcd_output_rw(0); 
0100:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0101:  MOVLW  0F
0102:  BSF    03.5
0103:  ANDWF  08,W
0104:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
0105:  BCF    08.0
....................    lcd_rs_tris(); 
0106:  BCF    08.1
....................    lcd_rw_tris(); 
0107:  BCF    08.2
....................  #endif 
....................      
....................    delay_ms(15); 
0108:  MOVLW  0F
0109:  BCF    03.5
010A:  MOVWF  53
010B:  CALL   08B
....................    for(i=1;i<=3;++i) 
010C:  MOVLW  01
010D:  MOVWF  45
010E:  MOVF   45,W
010F:  SUBLW  03
0110:  BTFSS  03.0
0111:  GOTO   11A
....................    { 
....................        lcd_send_nibble(3); 
0112:  MOVLW  03
0113:  MOVWF  5A
0114:  CALL   09F
....................        delay_ms(5); 
0115:  MOVLW  05
0116:  MOVWF  53
0117:  CALL   08B
0118:  INCF   45,F
0119:  GOTO   10E
....................    } 
....................     
....................    lcd_send_nibble(2); 
011A:  MOVLW  02
011B:  MOVWF  5A
011C:  CALL   09F
....................    delay_ms(5); 
011D:  MOVLW  05
011E:  MOVWF  53
011F:  CALL   08B
....................    for(i=0;i<=3;++i) 
0120:  CLRF   45
0121:  MOVF   45,W
0122:  SUBLW  03
0123:  BTFSS  03.0
0124:  GOTO   131
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0125:  MOVLW  46
0126:  ADDWF  45,W
0127:  MOVWF  04
0128:  BCF    03.7
0129:  MOVF   00,W
012A:  MOVWF  4A
012B:  CLRF   57
012C:  MOVF   4A,W
012D:  MOVWF  58
012E:  CALL   0B4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
012F:  INCF   45,F
0130:  GOTO   121
0131:  BSF    0A.3
0132:  BCF    0A.4
0133:  GOTO   1A4 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
05C4:  DECFSZ 54,W
05C5:  GOTO   5C7
05C6:  GOTO   5CA
....................       address=LCD_LINE_TWO; 
05C7:  MOVLW  40
05C8:  MOVWF  55
05C9:  GOTO   5CB
....................    else 
....................       address=0; 
05CA:  CLRF   55
....................       
....................    address+=x-1; 
05CB:  MOVLW  01
05CC:  SUBWF  53,W
05CD:  ADDWF  55,F
....................    lcd_send_byte(0,0x80|address); 
05CE:  MOVF   55,W
05CF:  IORLW  80
05D0:  MOVWF  56
05D1:  CLRF   57
05D2:  MOVF   56,W
05D3:  MOVWF  58
05D4:  CALL   0B4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
05D5:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
05D6:  MOVF   52,W
05D7:  XORLW  07
05D8:  BTFSC  03.2
05D9:  GOTO   5E4
05DA:  XORLW  0B
05DB:  BTFSC  03.2
05DC:  GOTO   5E9
05DD:  XORLW  06
05DE:  BTFSC  03.2
05DF:  GOTO   5F1
05E0:  XORLW  02
05E1:  BTFSC  03.2
05E2:  GOTO   5F7
05E3:  GOTO   5FC
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
05E4:  MOVLW  01
05E5:  MOVWF  53
05E6:  MOVWF  54
05E7:  CALL   5C4
05E8:  GOTO   601
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
05E9:  CLRF   57
05EA:  MOVLW  01
05EB:  MOVWF  58
05EC:  CALL   0B4
....................                      delay_ms(2); 
05ED:  MOVLW  02
05EE:  MOVWF  53
05EF:  CALL   08B
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
05F0:  GOTO   601
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
05F1:  MOVLW  01
05F2:  MOVWF  53
05F3:  MOVLW  02
05F4:  MOVWF  54
05F5:  CALL   5C4
05F6:  GOTO   601
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
05F7:  CLRF   57
05F8:  MOVLW  10
05F9:  MOVWF  58
05FA:  CALL   0B4
05FB:  GOTO   601
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
05FC:  MOVLW  01
05FD:  MOVWF  57
05FE:  MOVF   52,W
05FF:  MOVWF  58
0600:  CALL   0B4
....................      #endif 
....................    } 
0601:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... /* Prototipo de funciones */ 
.................... void escribir_i2c(); 
.................... void obtenerTemperatura(); 
.................... void leerEntrada(char* comando); 
.................... int analizaOpcion(char* comando); 
.................... int comparaStrings(char str1[], char str2[]); 
.................... int compareStrings(char* str1, char* str2); 
.................... int verificaPorcentaje(char *comando); 
.................... int PWM(int8 pwmCiclo); 
....................  
.................... int8 contador = 0; 
.................... char getch(void); 
.................... float valor_temperatura = 0.0; 
.................... int pwmGlobal = 130; 
....................  
.................... int verificaPorcentaje(char *comando) { 
....................    char *pointer; 
....................    pointer = comando; 
*
0424:  MOVF   50,W
0425:  MOVWF  52
0426:  MOVF   4F,W
0427:  MOVWF  51
....................    pointer += 4; 
0428:  MOVLW  04
0429:  ADDWF  51,F
042A:  BTFSC  03.0
042B:  INCF   52,F
....................    int porcentaje = atoi(pointer); 
042C:  MOVF   52,W
042D:  MOVWF  55
042E:  MOVF   51,W
042F:  MOVWF  54
*
052F:  MOVF   78,W
0530:  MOVWF  53
....................    if(porcentaje >= 0 && porcentaje <= 100) { 
0531:  MOVF   53,W
0532:  SUBLW  64
0533:  BTFSS  03.0
0534:  GOTO   538
....................       return porcentaje;       
0535:  MOVF   53,W
0536:  MOVWF  78
0537:  GOTO   53A
....................    } 
....................     
....................    return -1; 
0538:  MOVLW  FF
0539:  MOVWF  78
....................     
.................... } 
....................  
.................... int compareStrings(char* str1, char* str2) 
*
024B:  BSF    03.5
024C:  CLRF   53
.................... { 
....................     int i = 0; 
....................     while (str1[i] != '\0' && str2[i] != '\0') { 
024D:  MOVF   53,W
024E:  ADDWF  4F,W
024F:  MOVWF  04
0250:  BCF    03.7
0251:  BTFSC  50.0
0252:  BSF    03.7
0253:  MOVF   00,F
0254:  BTFSC  03.2
0255:  GOTO   276
0256:  MOVF   53,W
0257:  ADDWF  51,W
0258:  MOVWF  04
0259:  BCF    03.7
025A:  BTFSC  52.0
025B:  BSF    03.7
025C:  MOVF   00,F
025D:  BTFSC  03.2
025E:  GOTO   276
....................         if (str1[i] != str2[i]) { 
025F:  MOVF   53,W
0260:  ADDWF  4F,W
0261:  MOVWF  04
0262:  BCF    03.7
0263:  BTFSC  50.0
0264:  BSF    03.7
0265:  MOVF   00,W
0266:  MOVWF  54
0267:  MOVF   53,W
0268:  ADDWF  51,W
0269:  MOVWF  04
026A:  BCF    03.7
026B:  BTFSC  52.0
026C:  BSF    03.7
026D:  MOVF   00,W
026E:  SUBWF  54,W
026F:  BTFSC  03.2
0270:  GOTO   274
....................             return 0; 
0271:  MOVLW  00
0272:  MOVWF  78
0273:  GOTO   28D
....................         } 
....................         i++; 
0274:  INCF   53,F
0275:  GOTO   24D
....................     } 
....................     if (str1[i] == '\0' && str2[i] == '\0') { 
0276:  MOVF   53,W
0277:  ADDWF  4F,W
0278:  MOVWF  04
0279:  BCF    03.7
027A:  BTFSC  50.0
027B:  BSF    03.7
027C:  MOVF   00,F
027D:  BTFSS  03.2
027E:  GOTO   28B
027F:  MOVF   53,W
0280:  ADDWF  51,W
0281:  MOVWF  04
0282:  BCF    03.7
0283:  BTFSC  52.0
0284:  BSF    03.7
0285:  MOVF   00,F
0286:  BTFSS  03.2
0287:  GOTO   28B
....................         return 1; 
0288:  MOVLW  01
0289:  MOVWF  78
028A:  GOTO   28D
....................     } 
....................     return 0; 
028B:  MOVLW  00
028C:  MOVWF  78
028D:  BCF    03.5
028E:  RETURN
.................... } 
....................  
.................... void obtenerTemperatura() 
.................... { 
....................     set_adc_channel(0); 
*
0658:  MOVLW  00
0659:  MOVWF  78
065A:  MOVF   1F,W
065B:  ANDLW  C3
065C:  IORWF  78,W
065D:  MOVWF  1F
....................     delay_ms(10); 
065E:  MOVLW  0A
065F:  MOVWF  53
0660:  CALL   08B
....................     valor_temperatura = read_adc() * 2; 
0661:  BSF    1F.1
0662:  BTFSC  1F.1
0663:  GOTO   662
0664:  BCF    03.0
0665:  RLF    1E,W
0666:  CLRF   46
0667:  MOVWF  45
*
0684:  MOVF   7A,W
0685:  MOVWF  2B
0686:  MOVF   79,W
0687:  MOVWF  2A
0688:  MOVF   78,W
0689:  MOVWF  29
068A:  MOVF   77,W
068B:  MOVWF  28
068C:  BSF    0A.3
068D:  BCF    0A.4
068E:  GOTO   22E (RETURN)
.................... } 
....................  
.................... void escribir_i2c() 
.................... { 
....................     i2c_start(); 
....................     i2c_write(0x42); // Direcion del esclavo 
....................     i2c_write(contador); // El dato a escribir 
....................     i2c_stop(); 
.................... } 
....................  
.................... int PWM(int8 pwmCiclo) { 
*
075C:  MOVF   48,W
075D:  MOVWF  4A
075E:  MOVF   47,W
075F:  MOVWF  49
0760:  CLRF   4C
0761:  MOVLW  64
0762:  MOVWF  4B
*
0787:  MOVF   78,W
0788:  MOVWF  46
....................    int ciclo = 256 * pwmCiclo / 100; 
....................    return ciclo; 
0789:  MOVF   46,W
078A:  MOVWF  78
078B:  BSF    0A.3
078C:  BCF    0A.4
078D:  GOTO   2D6 (RETURN)
.................... } 
....................  
.................... void leerEntrada(char* comando) 
.................... { 
....................     char* ptr; 
....................     char ch; 
....................  
....................     ptr = comando; 
*
01E5:  MOVF   46,W
01E6:  MOVWF  48
01E7:  MOVF   45,W
01E8:  MOVWF  47
....................     printf("Ingrese comando: \n\r"); 
01E9:  MOVLW  04
01EA:  BSF    03.6
01EB:  MOVWF  0D
01EC:  MOVLW  00
01ED:  MOVWF  0F
01EE:  BCF    03.6
01EF:  CALL   134
....................     while ((ch = getchar()) != '\r') { 
01F0:  BTFSS  0C.5
01F1:  GOTO   1F0
01F2:  MOVF   1A,W
01F3:  MOVWF  49
01F4:  SUBLW  0D
01F5:  BTFSC  03.2
01F6:  GOTO   208
....................         printf("%c", ch); 
01F7:  MOVF   49,W
01F8:  BTFSS  0C.4
01F9:  GOTO   1F8
01FA:  MOVWF  19
....................         *ptr++ = (char)ch; 
01FB:  MOVF   48,W
01FC:  MOVWF  7A
01FD:  MOVF   47,W
01FE:  INCF   47,F
01FF:  BTFSC  03.2
0200:  INCF   48,F
0201:  MOVWF  04
0202:  BCF    03.7
0203:  BTFSC  7A.0
0204:  BSF    03.7
0205:  MOVF   49,W
0206:  MOVWF  00
0207:  GOTO   1F0
....................     } 
....................     printf("\n\r"); 
0208:  MOVLW  0A
0209:  BTFSS  0C.4
020A:  GOTO   209
020B:  MOVWF  19
020C:  MOVLW  0D
020D:  BTFSS  0C.4
020E:  GOTO   20D
020F:  MOVWF  19
....................     *ptr++ = 0; 
0210:  MOVF   48,W
0211:  MOVWF  7A
0212:  MOVF   47,W
0213:  INCF   47,F
0214:  BTFSC  03.2
0215:  INCF   48,F
0216:  MOVWF  04
0217:  BCF    03.7
0218:  BTFSC  7A.0
0219:  BSF    03.7
021A:  CLRF   00
....................  
....................     printf("The given string is : %s\n\r", comando); 
021B:  MOVLW  0E
021C:  BSF    03.6
021D:  MOVWF  0D
021E:  MOVLW  00
021F:  MOVWF  0F
0220:  BCF    03.0
0221:  MOVLW  16
0222:  BCF    03.6
0223:  MOVWF  4A
0224:  CALL   18C
0225:  MOVF   45,W
0226:  MOVWF  04
0227:  BCF    03.7
0228:  BTFSC  46.0
0229:  BSF    03.7
*
0240:  MOVLW  0A
0241:  BTFSS  0C.4
0242:  GOTO   241
0243:  MOVWF  19
0244:  MOVLW  0D
0245:  BTFSS  0C.4
0246:  GOTO   245
0247:  MOVWF  19
0248:  BSF    0A.3
0249:  BCF    0A.4
024A:  GOTO   1D8 (RETURN)
.................... } 
....................  
.................... int getCommand(char* entry) 
*
028F:  CLRF   6F
.................... { 
....................     char command[20]; 
....................     char parameter[20]; 
....................     int i = 0; 
....................     char *temperaturaString = "temperatura", 
0290:  MOVLW  74
0291:  BSF    03.5
0292:  MOVWF  20
0293:  MOVLW  65
0294:  MOVWF  21
0295:  MOVLW  6D
0296:  MOVWF  22
0297:  MOVLW  70
0298:  MOVWF  23
0299:  MOVLW  65
029A:  MOVWF  24
029B:  MOVLW  72
029C:  MOVWF  25
029D:  MOVLW  61
029E:  MOVWF  26
029F:  MOVLW  74
02A0:  MOVWF  27
02A1:  MOVLW  75
02A2:  MOVWF  28
02A3:  MOVLW  72
02A4:  MOVWF  29
02A5:  MOVLW  61
02A6:  MOVWF  2A
02A7:  CLRF   2B
02A8:  CLRF   71
02A9:  MOVLW  A0
02AA:  MOVWF  70
....................          *pwm = "pwm=", 
02AB:  MOVLW  70
02AC:  MOVWF  2C
02AD:  MOVLW  77
02AE:  MOVWF  2D
02AF:  MOVLW  6D
02B0:  MOVWF  2E
02B1:  MOVLW  3D
02B2:  MOVWF  2F
02B3:  CLRF   30
02B4:  CLRF   73
02B5:  MOVLW  AC
02B6:  MOVWF  72
....................          *motor = "motor", 
02B7:  MOVLW  6D
02B8:  MOVWF  31
02B9:  MOVLW  6F
02BA:  MOVWF  32
02BB:  MOVLW  74
02BC:  MOVWF  33
02BD:  MOVLW  6F
02BE:  MOVWF  34
02BF:  MOVLW  72
02C0:  MOVWF  35
02C1:  CLRF   36
02C2:  CLRF   75
02C3:  MOVLW  B1
02C4:  MOVWF  74
....................          *leds = "leds", 
02C5:  MOVLW  6C
02C6:  MOVWF  37
02C7:  MOVLW  65
02C8:  MOVWF  38
02C9:  MOVLW  64
02CA:  MOVWF  39
02CB:  MOVLW  73
02CC:  MOVWF  3A
02CD:  CLRF   3B
02CE:  CLRF   7C
02CF:  MOVLW  B7
02D0:  MOVWF  7B
....................          *offStr = "off", 
02D1:  MOVLW  6F
02D2:  MOVWF  3C
02D3:  MOVLW  66
02D4:  MOVWF  3D
02D5:  MOVWF  3E
02D6:  CLRF   3F
02D7:  CLRF   7E
02D8:  MOVLW  BC
02D9:  MOVWF  7D
....................          *onStr = "on"; 
02DA:  MOVLW  6F
02DB:  MOVWF  42
02DC:  MOVLW  6E
02DD:  MOVWF  43
02DE:  CLRF   44
02DF:  CLRF   41
02E0:  MOVLW  C2
02E1:  MOVWF  40
....................  
....................     while (entry[i] != ' ' && entry[i] != '\0') { 
02E2:  BCF    03.5
02E3:  MOVF   6F,W
02E4:  ADDWF  45,W
02E5:  MOVWF  04
02E6:  BCF    03.7
02E7:  BTFSC  46.0
02E8:  BSF    03.7
02E9:  MOVF   00,W
02EA:  SUBLW  20
02EB:  BTFSC  03.2
02EC:  GOTO   315
02ED:  MOVF   6F,W
02EE:  ADDWF  45,W
02EF:  MOVWF  04
02F0:  BCF    03.7
02F1:  BTFSC  46.0
02F2:  BSF    03.7
02F3:  MOVF   00,F
02F4:  BTFSC  03.2
02F5:  GOTO   315
....................         command[i] = entry[i]; 
02F6:  MOVLW  47
02F7:  ADDWF  6F,W
02F8:  MOVWF  78
02F9:  CLRF   7A
02FA:  BTFSC  03.0
02FB:  INCF   7A,F
02FC:  MOVF   78,W
02FD:  BSF    03.5
02FE:  MOVWF  46
02FF:  MOVF   7A,W
0300:  MOVWF  47
0301:  BCF    03.5
0302:  MOVF   6F,W
0303:  ADDWF  45,W
0304:  MOVWF  04
0305:  BCF    03.7
0306:  BTFSC  46.0
0307:  BSF    03.7
0308:  MOVF   00,W
0309:  BSF    03.5
030A:  MOVWF  48
030B:  MOVF   46,W
030C:  MOVWF  04
030D:  BCF    03.7
030E:  BTFSC  47.0
030F:  BSF    03.7
0310:  MOVF   48,W
0311:  MOVWF  00
....................         i++; 
0312:  BCF    03.5
0313:  INCF   6F,F
0314:  GOTO   2E3
....................     } 
....................     command[i] = '\0'; 
0315:  MOVLW  47
0316:  ADDWF  6F,W
0317:  MOVWF  04
0318:  BCF    03.7
0319:  CLRF   00
....................     if (entry[i] == ' ') { 
031A:  MOVF   6F,W
031B:  ADDWF  45,W
031C:  MOVWF  04
031D:  BCF    03.7
031E:  BTFSC  46.0
031F:  BSF    03.7
0320:  MOVF   00,W
0321:  SUBLW  20
0322:  BTFSC  03.2
....................         i++; 
0323:  INCF   6F,F
....................     } 
....................     int j = 0; 
0324:  CLRF   76
....................     while (entry[i] != '\0') { 
0325:  MOVF   6F,W
0326:  ADDWF  45,W
0327:  MOVWF  04
0328:  BCF    03.7
0329:  BTFSC  46.0
032A:  BSF    03.7
032B:  MOVF   00,F
032C:  BTFSC  03.2
032D:  GOTO   34E
....................         parameter[j] = entry[i]; 
032E:  MOVLW  5B
032F:  ADDWF  76,W
0330:  MOVWF  78
0331:  CLRF   7A
0332:  BTFSC  03.0
0333:  INCF   7A,F
0334:  MOVF   78,W
0335:  BSF    03.5
0336:  MOVWF  46
0337:  MOVF   7A,W
0338:  MOVWF  47
0339:  BCF    03.5
033A:  MOVF   6F,W
033B:  ADDWF  45,W
033C:  MOVWF  04
033D:  BCF    03.7
033E:  BTFSC  46.0
033F:  BSF    03.7
0340:  MOVF   00,W
0341:  BSF    03.5
0342:  MOVWF  48
0343:  MOVF   46,W
0344:  MOVWF  04
0345:  BCF    03.7
0346:  BTFSC  47.0
0347:  BSF    03.7
0348:  MOVF   48,W
0349:  MOVWF  00
....................         i++; 
034A:  BCF    03.5
034B:  INCF   6F,F
....................         j++; 
034C:  INCF   76,F
034D:  GOTO   325
....................     } 
....................     parameter[j] = '\0'; 
034E:  MOVLW  5B
034F:  ADDWF  76,W
0350:  MOVWF  04
0351:  BCF    03.7
0352:  CLRF   00
....................  
....................     if (compareStrings(command, temperaturaString)) { 
0353:  BSF    03.5
0354:  CLRF   50
0355:  MOVLW  47
0356:  MOVWF  4F
0357:  MOVF   71,W
0358:  MOVWF  52
0359:  MOVF   70,W
035A:  MOVWF  51
035B:  BCF    03.5
035C:  CALL   24B
035D:  MOVF   78,F
035E:  BTFSC  03.2
035F:  GOTO   364
....................         return 1; 
0360:  MOVLW  01
0361:  MOVWF  78
0362:  GOTO   54F
....................     } else if (compareStrings(command, motor)) { 
0363:  GOTO   54B
0364:  BSF    03.5
0365:  CLRF   50
0366:  MOVLW  47
0367:  MOVWF  4F
0368:  MOVF   75,W
0369:  MOVWF  52
036A:  MOVF   74,W
036B:  MOVWF  51
036C:  BCF    03.5
036D:  CALL   24B
036E:  MOVF   78,F
036F:  BTFSC  03.2
0370:  GOTO   396
....................         if (compareStrings(parameter, onStr)) { 
0371:  BSF    03.5
0372:  CLRF   50
0373:  MOVLW  5B
0374:  MOVWF  4F
0375:  MOVF   41,W
0376:  MOVWF  52
0377:  MOVF   40,W
0378:  MOVWF  51
0379:  BCF    03.5
037A:  CALL   24B
037B:  MOVF   78,F
037C:  BTFSC  03.2
037D:  GOTO   382
....................             return 2; 
037E:  MOVLW  02
037F:  MOVWF  78
0380:  GOTO   54F
....................         } else if (compareStrings(parameter, offStr)) { 
0381:  GOTO   392
0382:  BSF    03.5
0383:  CLRF   50
0384:  MOVLW  5B
0385:  MOVWF  4F
0386:  MOVF   7E,W
0387:  MOVWF  52
0388:  MOVF   7D,W
0389:  MOVWF  51
038A:  BCF    03.5
038B:  CALL   24B
038C:  MOVF   78,F
038D:  BTFSC  03.2
038E:  GOTO   392
....................             return 3; 
038F:  MOVLW  03
0390:  MOVWF  78
0391:  GOTO   54F
....................         } 
....................         return -1; 
0392:  MOVLW  FF
0393:  MOVWF  78
0394:  GOTO   54F
....................     } else if (compareStrings(command, leds)) { 
0395:  GOTO   54B
0396:  BSF    03.5
0397:  CLRF   50
0398:  MOVLW  47
0399:  MOVWF  4F
039A:  MOVF   7C,W
039B:  MOVWF  52
039C:  MOVF   7B,W
039D:  MOVWF  51
039E:  BCF    03.5
039F:  CALL   24B
03A0:  MOVF   78,F
03A1:  BTFSC  03.2
03A2:  GOTO   3C8
....................         if (compareStrings(parameter, onStr)) { 
03A3:  BSF    03.5
03A4:  CLRF   50
03A5:  MOVLW  5B
03A6:  MOVWF  4F
03A7:  MOVF   41,W
03A8:  MOVWF  52
03A9:  MOVF   40,W
03AA:  MOVWF  51
03AB:  BCF    03.5
03AC:  CALL   24B
03AD:  MOVF   78,F
03AE:  BTFSC  03.2
03AF:  GOTO   3B4
....................             return 4; 
03B0:  MOVLW  04
03B1:  MOVWF  78
03B2:  GOTO   54F
....................         } else if (compareStrings(parameter, offStr)) { 
03B3:  GOTO   3C4
03B4:  BSF    03.5
03B5:  CLRF   50
03B6:  MOVLW  5B
03B7:  MOVWF  4F
03B8:  MOVF   7E,W
03B9:  MOVWF  52
03BA:  MOVF   7D,W
03BB:  MOVWF  51
03BC:  BCF    03.5
03BD:  CALL   24B
03BE:  MOVF   78,F
03BF:  BTFSC  03.2
03C0:  GOTO   3C4
....................             return 5; 
03C1:  MOVLW  05
03C2:  MOVWF  78
03C3:  GOTO   54F
....................         } 
....................         return -1; 
03C4:  MOVLW  FF
03C5:  MOVWF  78
03C6:  GOTO   54F
....................     }else if (strstr(command, pwm)) { 
03C7:  GOTO   54B
03C8:  BSF    03.5
03C9:  CLRF   50
03CA:  MOVLW  47
03CB:  MOVWF  4F
03CC:  MOVF   73,W
03CD:  MOVWF  52
03CE:  MOVF   72,W
03CF:  MOVWF  51
*
041D:  MOVF   78,W
041E:  IORWF  79,W
041F:  BTFSC  03.2
0420:  GOTO   54C
....................       int porcentaje = verificaPorcentaje(command); 
0421:  CLRF   50
0422:  MOVLW  47
0423:  MOVWF  4F
*
053A:  MOVF   78,W
053B:  MOVWF  45
....................       if(porcentaje != -1) { 
053C:  MOVF   45,W
053D:  SUBLW  FF
053E:  BTFSC  03.2
053F:  GOTO   547
....................          pwmGlobal = porcentaje; 
0540:  MOVF   45,W
0541:  BCF    03.5
0542:  MOVWF  2C
....................          return 6; 
0543:  MOVLW  06
0544:  MOVWF  78
0545:  GOTO   54F
0546:  BSF    03.5
....................       } 
....................       return -1; 
0547:  MOVLW  FF
0548:  MOVWF  78
0549:  BCF    03.5
054A:  GOTO   54F
054B:  BSF    03.5
....................       
....................     } 
....................  
....................     return -1; 
054C:  MOVLW  FF
054D:  MOVWF  78
054E:  BCF    03.5
054F:  BSF    0A.3
0550:  BCF    0A.4
0551:  GOTO   1DE (RETURN)
.................... } 
....................  
.................... void encenderMotor() 
.................... { 
....................     output_low(PIN_C0); // Encender el motor conectado al pin C0 (Logica negada) 
*
0737:  BCF    26.0
0738:  MOVF   26,W
0739:  BSF    03.5
073A:  MOVWF  07
073B:  BCF    03.5
073C:  BCF    07.0
073D:  BSF    0A.3
073E:  BCF    0A.4
073F:  GOTO   265 (RETURN)
.................... } 
....................  
.................... void apagarMotor() 
.................... { 
....................     output_high(PIN_C0); // Apagar el motor conectado al pin C0 (Logica negada) 
0740:  BCF    26.0
0741:  MOVF   26,W
0742:  BSF    03.5
0743:  MOVWF  07
0744:  BCF    03.5
0745:  BSF    07.0
0746:  BSF    0A.3
0747:  BCF    0A.4
0748:  GOTO   282 (RETURN)
.................... } 
....................  
.................... void prenderLeds() 
.................... { 
....................     output_b(0xFF); // Prender todos los LEDs del puerto B 
0749:  BSF    03.5
074A:  CLRF   06
074B:  MOVLW  FF
074C:  BCF    03.5
074D:  MOVWF  06
074E:  BSF    0A.3
074F:  BCF    0A.4
0750:  GOTO   29F (RETURN)
.................... } 
....................  
.................... void apagarLeds() 
.................... { 
....................     output_b(0x00); // Apagar todos los LEDs del puerto B 
0751:  BSF    03.5
0752:  CLRF   06
0753:  BCF    03.5
0754:  CLRF   06
0755:  BSF    0A.3
0756:  BCF    0A.4
0757:  GOTO   2BC (RETURN)
.................... } 
....................  
.................... int main() 
*
0962:  MOVF   03,W
0963:  ANDLW  1F
0964:  MOVWF  03
0965:  BSF    03.5
0966:  BSF    03.6
0967:  BSF    07.3
0968:  MOVLW  08
0969:  BCF    03.6
096A:  MOVWF  19
096B:  MOVLW  02
096C:  MOVWF  1A
096D:  MOVLW  A6
096E:  MOVWF  18
096F:  MOVLW  90
0970:  BCF    03.5
0971:  MOVWF  18
0972:  MOVLW  FF
0973:  MOVWF  26
0974:  BSF    26.3
0975:  MOVF   26,W
0976:  BSF    03.5
0977:  MOVWF  07
0978:  BCF    03.5
0979:  BSF    26.4
097A:  MOVF   26,W
097B:  BSF    03.5
097C:  MOVWF  07
097D:  MOVLW  31
097E:  MOVWF  13
097F:  MOVLW  28
0980:  BCF    03.5
0981:  MOVWF  14
0982:  BSF    03.5
0983:  BSF    14.7
0984:  BCF    14.6
0985:  BCF    03.5
0986:  CLRF   27
0987:  CLRF   2B
0988:  CLRF   2A
0989:  CLRF   29
098A:  CLRF   28
098B:  MOVLW  82
098C:  MOVWF  2C
098D:  CLRF   2E
098E:  CLRF   2D
098F:  BSF    03.5
0990:  BSF    03.6
0991:  MOVF   09,W
0992:  ANDLW  C0
0993:  MOVWF  09
0994:  BCF    03.6
0995:  BCF    1F.4
0996:  BCF    1F.5
0997:  MOVLW  00
0998:  BSF    03.6
0999:  MOVWF  08
099A:  BCF    03.5
099B:  CLRF   07
099C:  CLRF   08
099D:  CLRF   09
099E:  BCF    03.7
.................... { 
....................     /* Configuracion */ 
....................     lcd_init(); 
*
09A2:  BCF    0A.3
09A3:  GOTO   0F6
09A4:  BSF    0A.3
....................     enable_interrupts(GLOBAL); 
09A5:  MOVLW  C0
09A6:  IORWF  0B,F
....................     Setup_port_a(ALL_ANALOG); 
09A7:  BSF    03.5
09A8:  BSF    03.6
09A9:  MOVF   09,W
09AA:  ANDLW  C0
09AB:  IORLW  1F
09AC:  MOVWF  09
09AD:  BCF    03.6
09AE:  BCF    1F.4
09AF:  BCF    1F.5
09B0:  MOVLW  FF
09B1:  BSF    03.6
09B2:  MOVWF  08
....................     Setup_adc(ADC_CLOCK_INTERNAL); 
09B3:  BCF    03.5
09B4:  BCF    03.6
09B5:  BSF    1F.6
09B6:  BSF    1F.7
09B7:  BSF    03.5
09B8:  BCF    1F.7
09B9:  BCF    03.5
09BA:  BSF    1F.0
....................     setup_ccp1(CCP_PWM); 
09BB:  BCF    26.2
09BC:  MOVF   26,W
09BD:  BSF    03.5
09BE:  MOVWF  07
09BF:  BCF    03.5
09C0:  BCF    07.2
09C1:  MOVLW  0C
09C2:  MOVWF  17
09C3:  BSF    03.5
09C4:  CLRF   1B
09C5:  CLRF   1C
09C6:  MOVLW  01
09C7:  MOVWF  1D
....................     setup_timer_2(T2_DIV_BY_16, 64, 1); 
09C8:  MOVLW  00
09C9:  MOVWF  78
09CA:  IORLW  06
09CB:  BCF    03.5
09CC:  MOVWF  12
09CD:  MOVLW  40
09CE:  BSF    03.5
09CF:  MOVWF  12
....................     set_pwm1_duty(pwmGlobal); 
09D0:  BCF    03.5
09D1:  MOVF   2C,W
09D2:  MOVWF  15
....................     while (TRUE) { 
....................         char comando[20]; 
....................         leerEntrada(&comando); 
09D3:  CLRF   46
09D4:  MOVLW  2F
09D5:  MOVWF  45
09D6:  BCF    0A.3
09D7:  GOTO   1E5
09D8:  BSF    0A.3
....................         // int opcion = analizaOpcion(comando); 
....................         int opcion = getCommand(comando); 
09D9:  CLRF   46
09DA:  MOVLW  2F
09DB:  MOVWF  45
09DC:  BCF    0A.3
09DD:  GOTO   28F
09DE:  BSF    0A.3
09DF:  MOVF   78,W
09E0:  MOVWF  43
....................         printf("Opcion: %d\n\r", opcion); 
09E1:  MOVLW  1C
09E2:  BSF    03.6
09E3:  MOVWF  0D
09E4:  MOVLW  00
09E5:  MOVWF  0F
09E6:  BCF    03.0
09E7:  MOVLW  08
09E8:  BCF    03.6
09E9:  MOVWF  4A
09EA:  BCF    0A.3
09EB:  CALL   18C
09EC:  BSF    0A.3
09ED:  MOVF   43,W
09EE:  MOVWF  45
09EF:  MOVLW  18
09F0:  MOVWF  46
09F1:  BCF    0A.3
09F2:  GOTO   567
09F3:  BSF    0A.3
09F4:  MOVLW  0A
09F5:  BTFSS  0C.4
09F6:  GOTO   1F5
09F7:  MOVWF  19
09F8:  MOVLW  0D
09F9:  BTFSS  0C.4
09FA:  GOTO   1F9
09FB:  MOVWF  19
....................         switch (opcion) { 
09FC:  MOVF   43,W
09FD:  BTFSC  03.2
09FE:  GOTO   212
09FF:  XORLW  01
0A00:  BTFSC  03.2
0A01:  GOTO   227
0A02:  XORLW  03
0A03:  BTFSC  03.2
0A04:  GOTO   25E
0A05:  XORLW  01
0A06:  BTFSC  03.2
0A07:  GOTO   27B
0A08:  XORLW  07
0A09:  BTFSC  03.2
0A0A:  GOTO   298
0A0B:  XORLW  01
0A0C:  BTFSC  03.2
0A0D:  GOTO   2B5
0A0E:  XORLW  03
0A0F:  BTFSC  03.2
0A10:  GOTO   2D2
0A11:  GOTO   2F5
....................         case 0: 
....................             lcd_putc('\f'); 
0A12:  MOVLW  0C
0A13:  MOVWF  52
0A14:  BCF    0A.3
0A15:  CALL   5D6
0A16:  BSF    0A.3
....................             lcd_gotoxy(0, 1); 
0A17:  CLRF   53
0A18:  MOVLW  01
0A19:  MOVWF  54
0A1A:  BCF    0A.3
0A1B:  CALL   5C4
0A1C:  BSF    0A.3
....................             printf(lcd_putc, " Esperando comando..."); 
0A1D:  MOVLW  23
0A1E:  BSF    03.6
0A1F:  MOVWF  0D
0A20:  MOVLW  00
0A21:  MOVWF  0F
0A22:  BCF    0A.3
0A23:  BCF    03.6
0A24:  CALL   602
0A25:  BSF    0A.3
....................             break; 
0A26:  GOTO   2FE
....................         // Temperatura 
....................         case 1: 
....................             lcd_putc('\f'); 
0A27:  MOVLW  0C
0A28:  MOVWF  52
0A29:  BCF    0A.3
0A2A:  CALL   5D6
0A2B:  BSF    0A.3
....................             obtenerTemperatura(); 
0A2C:  BCF    0A.3
0A2D:  GOTO   658
0A2E:  BSF    0A.3
....................             lcd_gotoxy(0, 1); 
0A2F:  CLRF   53
0A30:  MOVLW  01
0A31:  MOVWF  54
0A32:  BCF    0A.3
0A33:  CALL   5C4
0A34:  BSF    0A.3
....................             printf(lcd_putc, " Temp.: %f C", valor_temperatura); 
0A35:  MOVLW  2E
0A36:  BSF    03.6
0A37:  MOVWF  0D
0A38:  MOVLW  00
0A39:  MOVWF  0F
0A3A:  BCF    03.0
0A3B:  MOVLW  08
0A3C:  BCF    03.6
0A3D:  MOVWF  45
0A3E:  BCF    0A.3
0A3F:  GOTO   68F
0A40:  BSF    0A.3
0A41:  MOVLW  89
0A42:  MOVWF  04
0A43:  MOVF   2B,W
0A44:  MOVWF  48
0A45:  MOVF   2A,W
0A46:  MOVWF  47
0A47:  MOVF   29,W
0A48:  MOVWF  46
0A49:  MOVF   28,W
0A4A:  MOVWF  45
0A4B:  MOVLW  02
0A4C:  MOVWF  49
0A4D:  GOTO   000
0A4E:  MOVLW  20
0A4F:  MOVWF  52
0A50:  BCF    0A.3
0A51:  CALL   5D6
0A52:  BSF    0A.3
0A53:  MOVLW  43
0A54:  MOVWF  52
0A55:  BCF    0A.3
0A56:  CALL   5D6
0A57:  BSF    0A.3
....................             delay_ms(200); 
0A58:  MOVLW  C8
0A59:  MOVWF  53
0A5A:  BCF    0A.3
0A5B:  CALL   08B
0A5C:  BSF    0A.3
....................             break; 
0A5D:  GOTO   2FE
....................  
....................         // Motor on 
....................         case 2: 
....................             lcd_putc('\f'); 
0A5E:  MOVLW  0C
0A5F:  MOVWF  52
0A60:  BCF    0A.3
0A61:  CALL   5D6
0A62:  BSF    0A.3
....................             encenderMotor(); 
0A63:  BCF    0A.3
0A64:  GOTO   737
0A65:  BSF    0A.3
....................             lcd_gotoxy(0, 1); 
0A66:  CLRF   53
0A67:  MOVLW  01
0A68:  MOVWF  54
0A69:  BCF    0A.3
0A6A:  CALL   5C4
0A6B:  BSF    0A.3
....................             printf(lcd_putc, " Motor ON"); 
0A6C:  MOVLW  35
0A6D:  BSF    03.6
0A6E:  MOVWF  0D
0A6F:  MOVLW  00
0A70:  MOVWF  0F
0A71:  BCF    0A.3
0A72:  BCF    03.6
0A73:  CALL   602
0A74:  BSF    0A.3
....................             delay_ms(200); 
0A75:  MOVLW  C8
0A76:  MOVWF  53
0A77:  BCF    0A.3
0A78:  CALL   08B
0A79:  BSF    0A.3
....................             break; 
0A7A:  GOTO   2FE
....................  
....................         // Motor off 
....................         case 3: 
....................             lcd_putc('\f'); 
0A7B:  MOVLW  0C
0A7C:  MOVWF  52
0A7D:  BCF    0A.3
0A7E:  CALL   5D6
0A7F:  BSF    0A.3
....................             apagarMotor(); 
0A80:  BCF    0A.3
0A81:  GOTO   740
0A82:  BSF    0A.3
....................             lcd_gotoxy(0, 1); 
0A83:  CLRF   53
0A84:  MOVLW  01
0A85:  MOVWF  54
0A86:  BCF    0A.3
0A87:  CALL   5C4
0A88:  BSF    0A.3
....................             printf(lcd_putc, " Motor OFF"); 
0A89:  MOVLW  3A
0A8A:  BSF    03.6
0A8B:  MOVWF  0D
0A8C:  MOVLW  00
0A8D:  MOVWF  0F
0A8E:  BCF    0A.3
0A8F:  BCF    03.6
0A90:  CALL   602
0A91:  BSF    0A.3
....................             delay_ms(200); 
0A92:  MOVLW  C8
0A93:  MOVWF  53
0A94:  BCF    0A.3
0A95:  CALL   08B
0A96:  BSF    0A.3
....................             break; 
0A97:  GOTO   2FE
....................  
....................         // Leds on 
....................         case 4: 
....................             lcd_putc('\f'); 
0A98:  MOVLW  0C
0A99:  MOVWF  52
0A9A:  BCF    0A.3
0A9B:  CALL   5D6
0A9C:  BSF    0A.3
....................             prenderLeds(); 
0A9D:  BCF    0A.3
0A9E:  GOTO   749
0A9F:  BSF    0A.3
....................             lcd_gotoxy(0, 1); 
0AA0:  CLRF   53
0AA1:  MOVLW  01
0AA2:  MOVWF  54
0AA3:  BCF    0A.3
0AA4:  CALL   5C4
0AA5:  BSF    0A.3
....................             printf(lcd_putc, " Leds ON"); 
0AA6:  MOVLW  40
0AA7:  BSF    03.6
0AA8:  MOVWF  0D
0AA9:  MOVLW  00
0AAA:  MOVWF  0F
0AAB:  BCF    0A.3
0AAC:  BCF    03.6
0AAD:  CALL   602
0AAE:  BSF    0A.3
....................             delay_ms(200); 
0AAF:  MOVLW  C8
0AB0:  MOVWF  53
0AB1:  BCF    0A.3
0AB2:  CALL   08B
0AB3:  BSF    0A.3
....................             break; 
0AB4:  GOTO   2FE
....................  
....................         // Leds off 
....................         case 5: 
....................             lcd_putc('\f'); 
0AB5:  MOVLW  0C
0AB6:  MOVWF  52
0AB7:  BCF    0A.3
0AB8:  CALL   5D6
0AB9:  BSF    0A.3
....................             apagarLeds(); 
0ABA:  BCF    0A.3
0ABB:  GOTO   751
0ABC:  BSF    0A.3
....................             lcd_gotoxy(0, 1); 
0ABD:  CLRF   53
0ABE:  MOVLW  01
0ABF:  MOVWF  54
0AC0:  BCF    0A.3
0AC1:  CALL   5C4
0AC2:  BSF    0A.3
....................             printf(lcd_putc, " Leds OFF"); 
0AC3:  MOVLW  45
0AC4:  BSF    03.6
0AC5:  MOVWF  0D
0AC6:  MOVLW  00
0AC7:  MOVWF  0F
0AC8:  BCF    0A.3
0AC9:  BCF    03.6
0ACA:  CALL   602
0ACB:  BSF    0A.3
....................             delay_ms(200); 
0ACC:  MOVLW  C8
0ACD:  MOVWF  53
0ACE:  BCF    0A.3
0ACF:  CALL   08B
0AD0:  BSF    0A.3
....................             break; 
0AD1:  GOTO   2FE
....................         // PWM 
....................         case 6: 
....................             int ciclo = PWM(pwmGlobal); 
0AD2:  MOVF   2C,W
0AD3:  MOVWF  45
0AD4:  BCF    0A.3
0AD5:  GOTO   758
0AD6:  BSF    0A.3
0AD7:  MOVF   78,W
0AD8:  MOVWF  44
....................             set_pwm1_duty(ciclo); 
0AD9:  MOVF   44,W
0ADA:  MOVWF  15
....................             lcd_putc('\f'); 
0ADB:  MOVLW  0C
0ADC:  MOVWF  52
0ADD:  BCF    0A.3
0ADE:  CALL   5D6
0ADF:  BSF    0A.3
....................             lcd_gotoxy(0, 1); 
0AE0:  CLRF   53
0AE1:  MOVLW  01
0AE2:  MOVWF  54
0AE3:  BCF    0A.3
0AE4:  CALL   5C4
0AE5:  BSF    0A.3
....................             printf(lcd_putc, " PWM Exitoso!"); 
0AE6:  MOVLW  4A
0AE7:  BSF    03.6
0AE8:  MOVWF  0D
0AE9:  MOVLW  00
0AEA:  MOVWF  0F
0AEB:  BCF    0A.3
0AEC:  BCF    03.6
0AED:  CALL   602
0AEE:  BSF    0A.3
....................             delay_ms(200); 
0AEF:  MOVLW  C8
0AF0:  MOVWF  53
0AF1:  BCF    0A.3
0AF2:  CALL   08B
0AF3:  BSF    0A.3
....................             break; 
0AF4:  GOTO   2FE
....................         default: 
....................             printf("Ups, intenta de nuevo un comando invalido\n\rAlgunos comandos validos son:\n\rmotor on, pwm=50, leds off, temperatura\n\r"); 
0AF5:  MOVLW  51
0AF6:  BSF    03.6
0AF7:  MOVWF  0D
0AF8:  MOVLW  00
0AF9:  MOVWF  0F
0AFA:  BCF    0A.3
0AFB:  BCF    03.6
0AFC:  CALL   134
0AFD:  BSF    0A.3
....................             break; 
....................         } 
0AFE:  GOTO   1D3
....................     } 
....................  
....................     return 0; 
0AFF:  MOVLW  00
0B00:  MOVWF  78
.................... } 
0B01:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
