CCS PCM C Compiler, Version 5.076, 2401               11-jun.-23 21:13

               Filename:   \\Mac\Home\Documents\Development\Otros\Microcomputadoras\ProyectoFinal\PuertoSerial\PuertoSerial.lst

               ROM used:   2141 words (26%)
                           Largest free fragment is 2048
               RAM used:   41 (11%) at main() level
                           147 (40%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <16f887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0004:  DATA 49,37
0005:  DATA 67,39
0006:  DATA E5,39
0007:  DATA 65,10
0008:  DATA E3,37
0009:  DATA ED,30
000A:  DATA 6E,32
000B:  DATA 6F,1D
000C:  DATA 20,05
000D:  DATA 0D,00
000E:  DATA 54,34
000F:  DATA 65,10
0010:  DATA E7,34
0011:  DATA F6,32
0012:  DATA 6E,10
0013:  DATA 73,3A
0014:  DATA F2,34
0015:  DATA EE,33
0016:  DATA A0,34
0017:  DATA 73,10
0018:  DATA 3A,10
0019:  DATA A5,39
001A:  DATA 8A,06
001B:  DATA 00,00
001C:  DATA 4F,38
001D:  DATA E3,34
001E:  DATA 6F,37
001F:  DATA 3A,10
0020:  DATA 25,32
0021:  DATA 8A,06
0022:  DATA 80,3E
0023:  DATA A0,22
0024:  DATA 73,38
0025:  DATA 65,39
0026:  DATA 61,37
0027:  DATA E4,37
0028:  DATA A0,31
0029:  DATA EF,36
002A:  DATA 61,37
002B:  DATA E4,37
002C:  DATA 2E,17
002D:  DATA 2E,00
002E:  DATA 20,2A
002F:  DATA E5,36
0030:  DATA 70,17
0031:  DATA 3A,10
0032:  DATA 25,33
0033:  DATA A0,21
0034:  DATA 00,00
0035:  DATA A0,26
0036:  DATA 6F,3A
0037:  DATA 6F,39
0038:  DATA A0,27
0039:  DATA 4E,00
003A:  DATA A0,26
003B:  DATA 6F,3A
003C:  DATA 6F,39
003D:  DATA A0,27
003E:  DATA 46,23
003F:  DATA 00,01
0040:  DATA 20,26
0041:  DATA 65,32
0042:  DATA 73,10
0043:  DATA 4F,27
0044:  DATA 00,01
0045:  DATA 20,26
0046:  DATA 65,32
0047:  DATA 73,10
0048:  DATA 4F,23
0049:  DATA 46,00
004A:  DATA 55,38
004B:  DATA 73,16
004C:  DATA A0,34
004D:  DATA 6E,3A
004E:  DATA 65,37
004F:  DATA F4,30
0050:  DATA 20,32
0051:  DATA 65,10
0052:  DATA EE,3A
0053:  DATA 65,3B
0054:  DATA 6F,10
0055:  DATA 75,37
0056:  DATA A0,31
0057:  DATA EF,36
0058:  DATA 61,37
0059:  DATA E4,37
005A:  DATA A0,34
005B:  DATA 6E,3B
005C:  DATA 61,36
005D:  DATA 69,32
005E:  DATA 6F,05
005F:  DATA 8D,20
0060:  DATA EC,33
0061:  DATA 75,37
0062:  DATA EF,39
0063:  DATA A0,31
0064:  DATA EF,36
0065:  DATA 61,37
0066:  DATA E4,37
0067:  DATA 73,10
0068:  DATA F6,30
0069:  DATA EC,34
006A:  DATA E4,37
006B:  DATA 73,10
006C:  DATA F3,37
006D:  DATA 6E,1D
006E:  DATA 8A,06
006F:  DATA ED,37
0070:  DATA F4,37
0071:  DATA 72,10
0072:  DATA 6F,37
0073:  DATA 2C,10
0074:  DATA F0,3B
0075:  DATA ED,1E
0076:  DATA 35,18
0077:  DATA 2C,10
0078:  DATA EC,32
0079:  DATA E4,39
007A:  DATA A0,37
007B:  DATA 66,33
007C:  DATA 2C,10
007D:  DATA F4,32
007E:  DATA 6D,38
007F:  DATA 65,39
0080:  DATA 61,3A
0081:  DATA 75,39
0082:  DATA 61,05
0083:  DATA 0D,00
*
012D:  MOVF   0B,W
012E:  MOVWF  49
012F:  BCF    0B.7
0130:  BSF    03.5
0131:  BSF    03.6
0132:  BSF    0C.7
0133:  BSF    0C.0
0134:  NOP
0135:  NOP
0136:  BCF    03.5
0137:  BCF    03.6
0138:  BTFSC  49.7
0139:  BSF    0B.7
013A:  BSF    03.6
013B:  MOVF   0C,W
013C:  ANDLW  7F
013D:  BTFSC  03.2
013E:  GOTO   183
013F:  BCF    03.6
0140:  MOVWF  49
0141:  BSF    03.6
0142:  MOVF   0D,W
0143:  BCF    03.6
0144:  MOVWF  4A
0145:  BSF    03.6
0146:  MOVF   0F,W
0147:  BCF    03.6
0148:  MOVWF  4B
0149:  MOVF   49,W
014A:  BTFSS  0C.4
014B:  GOTO   14A
014C:  MOVWF  19
014D:  MOVF   4A,W
014E:  BSF    03.6
014F:  MOVWF  0D
0150:  BCF    03.6
0151:  MOVF   4B,W
0152:  BSF    03.6
0153:  MOVWF  0F
0154:  BCF    03.6
0155:  MOVF   0B,W
0156:  MOVWF  4C
0157:  BCF    0B.7
0158:  BSF    03.5
0159:  BSF    03.6
015A:  BSF    0C.7
015B:  BSF    0C.0
015C:  NOP
015D:  NOP
015E:  BCF    03.5
015F:  BCF    03.6
0160:  BTFSC  4C.7
0161:  BSF    0B.7
0162:  BSF    03.6
0163:  RLF    0C,W
0164:  RLF    0E,W
0165:  ANDLW  7F
0166:  BTFSC  03.2
0167:  GOTO   183
0168:  BCF    03.6
0169:  MOVWF  49
016A:  BSF    03.6
016B:  MOVF   0D,W
016C:  BCF    03.6
016D:  MOVWF  4A
016E:  BSF    03.6
016F:  MOVF   0F,W
0170:  BCF    03.6
0171:  MOVWF  4B
0172:  MOVF   49,W
0173:  BTFSS  0C.4
0174:  GOTO   173
0175:  MOVWF  19
0176:  MOVF   4A,W
0177:  BSF    03.6
0178:  MOVWF  0D
0179:  BCF    03.6
017A:  MOVF   4B,W
017B:  BSF    03.6
017C:  MOVWF  0F
017D:  INCF   0D,F
017E:  BTFSC  03.2
017F:  INCF   0F,F
0180:  BCF    03.6
0181:  GOTO   12D
0182:  BSF    03.6
0183:  BCF    03.6
0184:  RETURN
0185:  MOVF   0B,W
0186:  MOVWF  4A
0187:  BCF    0B.7
0188:  BSF    03.5
0189:  BSF    03.6
018A:  BSF    0C.7
018B:  BSF    0C.0
018C:  NOP
018D:  NOP
018E:  BCF    03.5
018F:  BCF    03.6
0190:  BTFSC  4A.7
0191:  BSF    0B.7
0192:  BTFSC  03.0
0193:  GOTO   1BD
0194:  BSF    03.6
0195:  MOVF   0C,W
0196:  ANDLW  7F
0197:  BCF    03.6
0198:  MOVWF  4A
0199:  BSF    03.6
019A:  MOVF   0D,W
019B:  BCF    03.6
019C:  MOVWF  4B
019D:  BSF    03.6
019E:  MOVF   0F,W
019F:  BCF    03.6
01A0:  MOVWF  4C
01A1:  MOVF   4A,W
01A2:  BTFSS  0C.4
01A3:  GOTO   1A2
01A4:  MOVWF  19
01A5:  MOVF   4B,W
01A6:  BSF    03.6
01A7:  MOVWF  0D
01A8:  BCF    03.6
01A9:  MOVF   4C,W
01AA:  BSF    03.6
01AB:  MOVWF  0F
01AC:  BCF    03.6
01AD:  MOVF   0B,W
01AE:  MOVWF  4D
01AF:  BCF    0B.7
01B0:  BSF    03.5
01B1:  BSF    03.6
01B2:  BSF    0C.7
01B3:  BSF    0C.0
01B4:  NOP
01B5:  NOP
01B6:  BCF    03.5
01B7:  BCF    03.6
01B8:  BTFSC  4D.7
01B9:  BSF    0B.7
01BA:  DECFSZ 49,F
01BB:  GOTO   1BD
01BC:  GOTO   1DD
01BD:  BSF    03.6
01BE:  RLF    0C,W
01BF:  RLF    0E,W
01C0:  ANDLW  7F
01C1:  BCF    03.6
01C2:  MOVWF  4A
01C3:  BSF    03.6
01C4:  MOVF   0D,W
01C5:  BCF    03.6
01C6:  MOVWF  4B
01C7:  BSF    03.6
01C8:  MOVF   0F,W
01C9:  BCF    03.6
01CA:  MOVWF  4C
01CB:  MOVF   4A,W
01CC:  BTFSS  0C.4
01CD:  GOTO   1CC
01CE:  MOVWF  19
01CF:  MOVF   4B,W
01D0:  BSF    03.6
01D1:  MOVWF  0D
01D2:  BCF    03.6
01D3:  MOVF   4C,W
01D4:  BSF    03.6
01D5:  MOVWF  0F
01D6:  INCF   0D,F
01D7:  BTFSC  03.2
01D8:  INCF   0F,F
01D9:  BCF    03.0
01DA:  BCF    03.6
01DB:  DECFSZ 49,F
01DC:  GOTO   185
01DD:  RETURN
*
0223:  MOVF   00,F
0224:  BTFSC  03.2
0225:  GOTO   239
0226:  CLRF   4A
0227:  MOVF   04,W
0228:  MOVWF  49
0229:  BCF    4A.0
022A:  BTFSC  03.7
022B:  BSF    4A.0
022C:  MOVF   00,W
022D:  BTFSS  0C.4
022E:  GOTO   22D
022F:  MOVWF  19
0230:  MOVF   49,W
0231:  MOVWF  04
0232:  BCF    03.7
0233:  BTFSC  4A.0
0234:  BSF    03.7
0235:  INCF   04,F
0236:  BTFSC  03.2
0237:  INCF   05,F
0238:  GOTO   223
*
03CB:  MOVF   4B,W
03CC:  CLRF   78
03CD:  SUBWF  4A,W
03CE:  BTFSC  03.0
03CF:  GOTO   3D3
03D0:  MOVF   4A,W
03D1:  MOVWF  77
03D2:  GOTO   3DF
03D3:  CLRF   77
03D4:  MOVLW  08
03D5:  MOVWF  4C
03D6:  RLF    4A,F
03D7:  RLF    77,F
03D8:  MOVF   4B,W
03D9:  SUBWF  77,W
03DA:  BTFSC  03.0
03DB:  MOVWF  77
03DC:  RLF    78,F
03DD:  DECFSZ 4C,F
03DE:  GOTO   3D6
03DF:  RETURN
03E0:  MOVLW  20
03E1:  BTFSS  45.4
03E2:  MOVLW  30
03E3:  MOVWF  46
03E4:  MOVF   44,W
03E5:  MOVWF  77
03E6:  BTFSS  44.7
03E7:  GOTO   3F0
03E8:  COMF   77,F
03E9:  INCF   77,F
03EA:  MOVF   77,W
03EB:  MOVWF  44
03EC:  MOVLW  2D
03ED:  MOVWF  46
03EE:  BSF    45.7
03EF:  BSF    45.0
03F0:  MOVF   44,W
03F1:  MOVWF  4A
03F2:  MOVLW  64
03F3:  MOVWF  4B
03F4:  CALL   3CB
03F5:  MOVF   77,W
03F6:  MOVWF  44
03F7:  MOVLW  30
03F8:  ADDWF  78,W
03F9:  MOVWF  47
03FA:  MOVF   44,W
03FB:  MOVWF  4A
03FC:  MOVLW  0A
03FD:  MOVWF  4B
03FE:  CALL   3CB
03FF:  MOVLW  30
0400:  ADDWF  77,W
0401:  MOVWF  49
0402:  MOVLW  30
0403:  ADDWF  78,W
0404:  MOVWF  48
0405:  MOVF   46,W
0406:  MOVWF  77
0407:  MOVLW  30
0408:  SUBWF  47,W
0409:  BTFSC  03.2
040A:  GOTO   40F
040B:  BSF    45.1
040C:  BTFSC  45.7
040D:  BSF    45.2
040E:  GOTO   423
040F:  MOVF   46,W
0410:  MOVWF  47
0411:  MOVLW  20
0412:  MOVWF  46
0413:  MOVLW  30
0414:  SUBWF  48,W
0415:  BTFSC  03.2
0416:  GOTO   41B
0417:  BSF    45.0
0418:  BTFSC  45.7
0419:  BSF    45.1
041A:  GOTO   423
041B:  BTFSS  03.2
041C:  BSF    45.0
041D:  BTFSS  03.2
041E:  GOTO   423
041F:  MOVF   47,W
0420:  MOVWF  48
0421:  MOVLW  20
0422:  MOVWF  47
0423:  BTFSC  45.2
0424:  GOTO   42A
0425:  BTFSC  45.1
0426:  GOTO   42E
0427:  BTFSC  45.0
0428:  GOTO   432
0429:  GOTO   436
042A:  MOVF   46,W
042B:  BTFSS  0C.4
042C:  GOTO   42B
042D:  MOVWF  19
042E:  MOVF   47,W
042F:  BTFSS  0C.4
0430:  GOTO   42F
0431:  MOVWF  19
0432:  MOVF   48,W
0433:  BTFSS  0C.4
0434:  GOTO   433
0435:  MOVWF  19
0436:  MOVF   49,W
0437:  BTFSS  0C.4
0438:  GOTO   437
0439:  MOVWF  19
043A:  BSF    0A.3
043B:  BCF    0A.4
043C:  GOTO   078 (RETURN)
*
047B:  MOVF   0B,W
047C:  MOVWF  44
047D:  BCF    0B.7
047E:  BSF    03.5
047F:  BSF    03.6
0480:  BSF    0C.7
0481:  BSF    0C.0
0482:  NOP
0483:  NOP
0484:  BCF    03.5
0485:  BCF    03.6
0486:  BTFSC  44.7
0487:  BSF    0B.7
0488:  BSF    03.6
0489:  MOVF   0C,W
048A:  ANDLW  7F
048B:  BTFSC  03.2
048C:  GOTO   4CF
048D:  BCF    03.6
048E:  MOVWF  44
048F:  BSF    03.6
0490:  MOVF   0D,W
0491:  BCF    03.6
0492:  MOVWF  45
0493:  BSF    03.6
0494:  MOVF   0F,W
0495:  BCF    03.6
0496:  MOVWF  46
0497:  MOVF   44,W
0498:  MOVWF  51
0499:  CALL   44F
049A:  MOVF   45,W
049B:  BSF    03.6
049C:  MOVWF  0D
049D:  BCF    03.6
049E:  MOVF   46,W
049F:  BSF    03.6
04A0:  MOVWF  0F
04A1:  BCF    03.6
04A2:  MOVF   0B,W
04A3:  MOVWF  47
04A4:  BCF    0B.7
04A5:  BSF    03.5
04A6:  BSF    03.6
04A7:  BSF    0C.7
04A8:  BSF    0C.0
04A9:  NOP
04AA:  NOP
04AB:  BCF    03.5
04AC:  BCF    03.6
04AD:  BTFSC  47.7
04AE:  BSF    0B.7
04AF:  BSF    03.6
04B0:  RLF    0C,W
04B1:  RLF    0E,W
04B2:  ANDLW  7F
04B3:  BTFSC  03.2
04B4:  GOTO   4CF
04B5:  BCF    03.6
04B6:  MOVWF  44
04B7:  BSF    03.6
04B8:  MOVF   0D,W
04B9:  BCF    03.6
04BA:  MOVWF  45
04BB:  BSF    03.6
04BC:  MOVF   0F,W
04BD:  BCF    03.6
04BE:  MOVWF  46
04BF:  MOVF   44,W
04C0:  MOVWF  51
04C1:  CALL   44F
04C2:  MOVF   45,W
04C3:  BSF    03.6
04C4:  MOVWF  0D
04C5:  BCF    03.6
04C6:  MOVF   46,W
04C7:  BSF    03.6
04C8:  MOVWF  0F
04C9:  INCF   0D,F
04CA:  BTFSC  03.2
04CB:  INCF   0F,F
04CC:  BCF    03.6
04CD:  GOTO   47B
04CE:  BSF    03.6
04CF:  BCF    03.6
04D0:  RETURN
*
04E1:  MOVLW  8E
04E2:  MOVWF  77
04E3:  MOVF   45,W
04E4:  MOVWF  78
04E5:  MOVF   44,W
04E6:  MOVWF  79
04E7:  CLRF   7A
04E8:  MOVF   78,F
04E9:  BTFSS  03.2
04EA:  GOTO   4F5
04EB:  MOVF   79,W
04EC:  MOVWF  78
04ED:  CLRF   79
04EE:  MOVLW  08
04EF:  SUBWF  77,F
04F0:  MOVF   78,F
04F1:  BTFSS  03.2
04F2:  GOTO   4F5
04F3:  CLRF   77
04F4:  GOTO   4FD
04F5:  BCF    03.0
04F6:  BTFSC  78.7
04F7:  GOTO   4FC
04F8:  RLF    79,F
04F9:  RLF    78,F
04FA:  DECF   77,F
04FB:  GOTO   4F5
04FC:  BCF    78.7
*
0508:  MOVF   0B,W
0509:  MOVWF  45
050A:  BCF    0B.7
050B:  BSF    03.5
050C:  BSF    03.6
050D:  BSF    0C.7
050E:  BSF    0C.0
050F:  NOP
0510:  NOP
0511:  BCF    03.5
0512:  BCF    03.6
0513:  BTFSC  45.7
0514:  BSF    0B.7
0515:  BTFSC  03.0
0516:  GOTO   53F
0517:  BSF    03.6
0518:  MOVF   0C,W
0519:  ANDLW  7F
051A:  BCF    03.6
051B:  MOVWF  45
051C:  BSF    03.6
051D:  MOVF   0D,W
051E:  BCF    03.6
051F:  MOVWF  46
0520:  BSF    03.6
0521:  MOVF   0F,W
0522:  BCF    03.6
0523:  MOVWF  47
0524:  MOVF   45,W
0525:  MOVWF  51
0526:  CALL   44F
0527:  MOVF   46,W
0528:  BSF    03.6
0529:  MOVWF  0D
052A:  BCF    03.6
052B:  MOVF   47,W
052C:  BSF    03.6
052D:  MOVWF  0F
052E:  BCF    03.6
052F:  MOVF   0B,W
0530:  MOVWF  48
0531:  BCF    0B.7
0532:  BSF    03.5
0533:  BSF    03.6
0534:  BSF    0C.7
0535:  BSF    0C.0
0536:  NOP
0537:  NOP
0538:  BCF    03.5
0539:  BCF    03.6
053A:  BTFSC  48.7
053B:  BSF    0B.7
053C:  DECFSZ 44,F
053D:  GOTO   53F
053E:  GOTO   55E
053F:  BSF    03.6
0540:  RLF    0C,W
0541:  RLF    0E,W
0542:  ANDLW  7F
0543:  BCF    03.6
0544:  MOVWF  45
0545:  BSF    03.6
0546:  MOVF   0D,W
0547:  BCF    03.6
0548:  MOVWF  46
0549:  BSF    03.6
054A:  MOVF   0F,W
054B:  BCF    03.6
054C:  MOVWF  47
054D:  MOVF   45,W
054E:  MOVWF  51
054F:  CALL   44F
0550:  MOVF   46,W
0551:  BSF    03.6
0552:  MOVWF  0D
0553:  BCF    03.6
0554:  MOVF   47,W
0555:  BSF    03.6
0556:  MOVWF  0F
0557:  INCF   0D,F
0558:  BTFSC  03.2
0559:  INCF   0F,F
055A:  BCF    03.0
055B:  BCF    03.6
055C:  DECFSZ 44,F
055D:  GOTO   508
055E:  BSF    0A.3
055F:  BCF    0A.4
0560:  GOTO   0C2 (RETURN)
0561:  BTFSC  03.1
0562:  GOTO   566
0563:  MOVLW  59
0564:  MOVWF  04
0565:  BCF    03.7
0566:  CLRF   77
0567:  CLRF   78
0568:  CLRF   79
0569:  CLRF   7A
056A:  CLRF   59
056B:  CLRF   5A
056C:  CLRF   5B
056D:  CLRF   5C
056E:  MOVF   58,W
056F:  IORWF  57,W
0570:  IORWF  56,W
0571:  IORWF  55,W
0572:  BTFSC  03.2
0573:  GOTO   5A4
0574:  MOVLW  20
0575:  MOVWF  5D
0576:  BCF    03.0
0577:  RLF    51,F
0578:  RLF    52,F
0579:  RLF    53,F
057A:  RLF    54,F
057B:  RLF    59,F
057C:  RLF    5A,F
057D:  RLF    5B,F
057E:  RLF    5C,F
057F:  MOVF   58,W
0580:  SUBWF  5C,W
0581:  BTFSS  03.2
0582:  GOTO   58D
0583:  MOVF   57,W
0584:  SUBWF  5B,W
0585:  BTFSS  03.2
0586:  GOTO   58D
0587:  MOVF   56,W
0588:  SUBWF  5A,W
0589:  BTFSS  03.2
058A:  GOTO   58D
058B:  MOVF   55,W
058C:  SUBWF  59,W
058D:  BTFSS  03.0
058E:  GOTO   59E
058F:  MOVF   55,W
0590:  SUBWF  59,F
0591:  MOVF   56,W
0592:  BTFSS  03.0
0593:  INCFSZ 56,W
0594:  SUBWF  5A,F
0595:  MOVF   57,W
0596:  BTFSS  03.0
0597:  INCFSZ 57,W
0598:  SUBWF  5B,F
0599:  MOVF   58,W
059A:  BTFSS  03.0
059B:  INCFSZ 58,W
059C:  SUBWF  5C,F
059D:  BSF    03.0
059E:  RLF    77,F
059F:  RLF    78,F
05A0:  RLF    79,F
05A1:  RLF    7A,F
05A2:  DECFSZ 5D,F
05A3:  GOTO   576
05A4:  MOVF   59,W
05A5:  MOVWF  00
05A6:  INCF   04,F
05A7:  MOVF   5A,W
05A8:  MOVWF  00
05A9:  INCF   04,F
05AA:  MOVF   5B,W
05AB:  MOVWF  00
05AC:  INCF   04,F
05AD:  MOVF   5C,W
05AE:  MOVWF  00
05AF:  RETURN
05B0:  MOVF   04,W
05B1:  MOVWF  49
05B2:  MOVF   48,W
05B3:  MOVWF  4B
05B4:  BTFSC  03.2
05B5:  GOTO   642
05B6:  MOVF   47,W
05B7:  MOVWF  54
05B8:  MOVF   46,W
05B9:  MOVWF  53
05BA:  MOVF   45,W
05BB:  MOVWF  52
05BC:  MOVF   44,W
05BD:  MOVWF  51
05BE:  CLRF   58
05BF:  CLRF   57
05C0:  MOVLW  20
05C1:  MOVWF  56
05C2:  MOVLW  82
05C3:  MOVWF  55
05C4:  MOVF   51,W
05C5:  BTFSC  03.2
05C6:  GOTO   634
05C7:  MOVWF  59
05C8:  MOVF   55,W
05C9:  BTFSC  03.2
05CA:  GOTO   634
05CB:  ADDWF  59,F
05CC:  BTFSC  03.0
05CD:  GOTO   5D5
05CE:  MOVLW  7F
05CF:  SUBWF  59,F
05D0:  BTFSS  03.0
05D1:  GOTO   634
05D2:  BTFSC  03.2
05D3:  GOTO   634
05D4:  GOTO   5D9
05D5:  MOVLW  81
05D6:  ADDWF  59,F
05D7:  BTFSC  03.0
05D8:  GOTO   634
05D9:  MOVF   59,W
05DA:  MOVWF  77
05DB:  CLRF   78
05DC:  CLRF   79
05DD:  CLRF   7A
05DE:  MOVF   52,W
05DF:  MOVWF  5D
05E0:  BSF    5D.7
05E1:  MOVF   53,W
05E2:  MOVWF  5C
05E3:  MOVF   54,W
05E4:  MOVWF  5B
05E5:  MOVLW  18
05E6:  MOVWF  59
05E7:  CLRF   5A
05E8:  BTFSS  5B.0
05E9:  GOTO   602
05EA:  MOVF   58,W
05EB:  ADDWF  7A,F
05EC:  BTFSS  03.0
05ED:  GOTO   5F4
05EE:  INCF   79,F
05EF:  BTFSS  03.2
05F0:  GOTO   5F4
05F1:  INCF   78,F
05F2:  BTFSC  03.2
05F3:  BSF    5A.7
05F4:  MOVF   57,W
05F5:  ADDWF  79,F
05F6:  BTFSS  03.0
05F7:  GOTO   5FB
05F8:  INCF   78,F
05F9:  BTFSC  03.2
05FA:  BSF    5A.7
05FB:  MOVF   56,W
05FC:  MOVWF  53
05FD:  BSF    53.7
05FE:  MOVF   53,W
05FF:  ADDWF  78,F
0600:  BTFSC  03.0
0601:  BSF    5A.7
0602:  RLF    5A,F
0603:  RRF    78,F
0604:  RRF    79,F
0605:  RRF    7A,F
0606:  RRF    5D,F
0607:  RRF    5C,F
0608:  RRF    5B,F
0609:  BCF    03.0
060A:  DECFSZ 59,F
060B:  GOTO   5E7
060C:  MOVLW  01
060D:  ADDWF  77,F
060E:  BTFSC  03.0
060F:  GOTO   634
0610:  BTFSC  78.7
0611:  GOTO   619
0612:  RLF    5D,F
0613:  RLF    7A,F
0614:  RLF    79,F
0615:  RLF    78,F
0616:  DECF   77,F
0617:  BTFSC  03.2
0618:  GOTO   634
0619:  BTFSS  5D.7
061A:  GOTO   62A
061B:  INCF   7A,F
061C:  BTFSS  03.2
061D:  GOTO   62A
061E:  INCF   79,F
061F:  BTFSS  03.2
0620:  GOTO   62A
0621:  INCF   78,F
0622:  BTFSS  03.2
0623:  GOTO   62A
0624:  RRF    78,F
0625:  RRF    79,F
0626:  RRF    7A,F
0627:  INCF   77,F
0628:  BTFSC  03.2
0629:  GOTO   634
062A:  MOVF   52,W
062B:  MOVWF  5A
062C:  MOVF   56,W
062D:  XORWF  5A,F
062E:  BTFSS  5A.7
062F:  GOTO   632
0630:  BSF    78.7
0631:  GOTO   638
0632:  BCF    78.7
0633:  GOTO   638
0634:  CLRF   77
0635:  CLRF   78
0636:  CLRF   79
0637:  CLRF   7A
0638:  MOVF   7A,W
0639:  MOVWF  47
063A:  MOVF   79,W
063B:  MOVWF  46
063C:  MOVF   78,W
063D:  MOVWF  45
063E:  MOVF   77,W
063F:  MOVWF  44
0640:  DECFSZ 4B,F
0641:  GOTO   5B6
0642:  MOVF   47,W
0643:  MOVWF  54
0644:  MOVF   46,W
0645:  MOVWF  53
0646:  MOVF   45,W
0647:  MOVWF  52
0648:  MOVF   44,W
0649:  MOVWF  51
064A:  MOVF   51,W
064B:  SUBLW  B6
064C:  MOVWF  51
064D:  CLRF   7A
064E:  MOVF   52,W
064F:  MOVWF  55
0650:  BSF    52.7
0651:  BCF    03.0
0652:  RRF    52,F
0653:  RRF    53,F
0654:  RRF    54,F
0655:  RRF    7A,F
0656:  RRF    79,F
0657:  RRF    78,F
0658:  RRF    77,F
0659:  DECFSZ 51,F
065A:  GOTO   651
065B:  BTFSS  55.7
065C:  GOTO   668
065D:  COMF   77,F
065E:  COMF   78,F
065F:  COMF   79,F
0660:  COMF   7A,F
0661:  INCF   77,F
0662:  BTFSC  03.2
0663:  INCF   78,F
0664:  BTFSC  03.2
0665:  INCF   79,F
0666:  BTFSC  03.2
0667:  INCF   7A,F
0668:  MOVF   7A,W
0669:  MOVWF  47
066A:  MOVF   79,W
066B:  MOVWF  46
066C:  MOVF   78,W
066D:  MOVWF  45
066E:  MOVF   77,W
066F:  MOVWF  44
0670:  BTFSS  47.7
0671:  GOTO   67F
0672:  DECF   49,F
0673:  BSF    49.5
0674:  COMF   44,F
0675:  COMF   45,F
0676:  COMF   46,F
0677:  COMF   47,F
0678:  INCF   44,F
0679:  BTFSC  03.2
067A:  INCF   45,F
067B:  BTFSC  03.2
067C:  INCF   46,F
067D:  BTFSC  03.2
067E:  INCF   47,F
067F:  MOVLW  3B
0680:  MOVWF  50
0681:  MOVLW  9A
0682:  MOVWF  4F
0683:  MOVLW  CA
0684:  MOVWF  4E
0685:  CLRF   4D
0686:  MOVLW  0A
0687:  MOVWF  4B
0688:  MOVF   48,W
0689:  BTFSC  03.2
068A:  INCF   49,F
068B:  BSF    03.1
068C:  MOVLW  44
068D:  MOVWF  04
068E:  BCF    03.7
068F:  MOVF   47,W
0690:  MOVWF  54
0691:  MOVF   46,W
0692:  MOVWF  53
0693:  MOVF   45,W
0694:  MOVWF  52
0695:  MOVF   44,W
0696:  MOVWF  51
0697:  MOVF   50,W
0698:  MOVWF  58
0699:  MOVF   4F,W
069A:  MOVWF  57
069B:  MOVF   4E,W
069C:  MOVWF  56
069D:  MOVF   4D,W
069E:  MOVWF  55
069F:  CALL   561
06A0:  MOVF   78,W
06A1:  MOVF   77,F
06A2:  BTFSS  03.2
06A3:  GOTO   6B7
06A4:  INCF   48,W
06A5:  SUBWF  4B,W
06A6:  BTFSC  03.2
06A7:  GOTO   6B7
06A8:  MOVF   49,W
06A9:  BTFSC  03.2
06AA:  GOTO   6B9
06AB:  ANDLW  0F
06AC:  SUBWF  4B,W
06AD:  BTFSC  03.2
06AE:  GOTO   6B1
06AF:  BTFSC  03.0
06B0:  GOTO   6E9
06B1:  BTFSC  49.7
06B2:  GOTO   6E9
06B3:  BTFSC  49.6
06B4:  GOTO   6B9
06B5:  MOVLW  20
06B6:  GOTO   6E5
06B7:  MOVLW  20
06B8:  ANDWF  49,F
06B9:  BTFSS  49.5
06BA:  GOTO   6C7
06BB:  BCF    49.5
06BC:  MOVF   48,W
06BD:  BTFSS  03.2
06BE:  DECF   49,F
06BF:  MOVF   77,W
06C0:  MOVWF  49
06C1:  MOVLW  2D
06C2:  MOVWF  51
06C3:  CALL   44F
06C4:  MOVF   49,W
06C5:  MOVWF  77
06C6:  CLRF   49
06C7:  MOVF   48,W
06C8:  SUBWF  4B,W
06C9:  BTFSS  03.2
06CA:  GOTO   6D5
06CB:  MOVF   77,W
06CC:  MOVWF  49
06CD:  MOVLW  2E
06CE:  MOVWF  51
06CF:  CALL   44F
06D0:  MOVF   49,W
06D1:  MOVWF  77
06D2:  MOVLW  20
06D3:  ANDWF  49,F
06D4:  MOVLW  00
06D5:  MOVLW  30
06D6:  BTFSS  49.5
06D7:  GOTO   6E5
06D8:  BCF    49.5
06D9:  MOVF   48,W
06DA:  BTFSS  03.2
06DB:  DECF   49,F
06DC:  MOVF   77,W
06DD:  MOVWF  49
06DE:  MOVLW  2D
06DF:  MOVWF  51
06E0:  CALL   44F
06E1:  MOVF   49,W
06E2:  MOVWF  77
06E3:  CLRF   49
06E4:  MOVLW  30
06E5:  ADDWF  77,F
06E6:  MOVF   77,W
06E7:  MOVWF  51
06E8:  CALL   44F
06E9:  BCF    03.1
06EA:  MOVF   50,W
06EB:  MOVWF  54
06EC:  MOVF   4F,W
06ED:  MOVWF  53
06EE:  MOVF   4E,W
06EF:  MOVWF  52
06F0:  MOVF   4D,W
06F1:  MOVWF  51
06F2:  CLRF   58
06F3:  CLRF   57
06F4:  CLRF   56
06F5:  MOVLW  0A
06F6:  MOVWF  55
06F7:  CALL   561
06F8:  MOVF   7A,W
06F9:  MOVWF  50
06FA:  MOVF   79,W
06FB:  MOVWF  4F
06FC:  MOVF   78,W
06FD:  MOVWF  4E
06FE:  MOVF   77,W
06FF:  MOVWF  4D
0700:  DECFSZ 4B,F
0701:  GOTO   68B
0702:  BSF    0A.3
0703:  BCF    0A.4
0704:  GOTO   0D1 (RETURN)
....................  
.................... #list 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
083C:  BCF    03.6
083D:  CLRF   20
083E:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #fuses HS, NOWDT, NOPROTECT, NOLVP 
.................... #use delay(clock = 20M) 
*
0084:  MOVLW  52
0085:  MOVWF  04
0086:  BCF    03.7
0087:  MOVF   00,W
0088:  BTFSC  03.2
0089:  GOTO   097
008A:  MOVLW  06
008B:  MOVWF  78
008C:  CLRF   77
008D:  DECFSZ 77,F
008E:  GOTO   08D
008F:  DECFSZ 78,F
0090:  GOTO   08C
0091:  MOVLW  7B
0092:  MOVWF  77
0093:  DECFSZ 77,F
0094:  GOTO   093
0095:  DECFSZ 00,F
0096:  GOTO   08A
0097:  RETURN
.................... #use rs232(baud = 9600, xmit = PIN_C6, rcv = PIN_C7) 
.................... #use i2c(MASTER, SDA = PIN_C4, SCL = PIN_C3, SLOW, NOFORCE_SW) 
.................... // #include "i2c-lcd.c" 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
00B3:  MOVLW  0F
00B4:  BSF    03.5
00B5:  ANDWF  08,W
00B6:  IORLW  F0
00B7:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00B8:  BCF    03.5
00B9:  BSF    08.2
....................    delay_cycles(1); 
00BA:  NOP
....................    lcd_output_enable(1); 
00BB:  BSF    08.0
....................    delay_cycles(1); 
00BC:  NOP
....................    high = lcd_read_nibble(); 
00BD:  CALL   0A7
00BE:  MOVF   78,W
00BF:  MOVWF  59
....................        
....................    lcd_output_enable(0); 
00C0:  BCF    08.0
....................    delay_cycles(1); 
00C1:  NOP
....................    lcd_output_enable(1); 
00C2:  BSF    08.0
....................    delay_us(1); 
00C3:  GOTO   0C4
00C4:  GOTO   0C5
00C5:  NOP
....................    low = lcd_read_nibble(); 
00C6:  CALL   0A7
00C7:  MOVF   78,W
00C8:  MOVWF  58
....................        
....................    lcd_output_enable(0); 
00C9:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00CA:  MOVLW  0F
00CB:  BSF    03.5
00CC:  ANDWF  08,W
00CD:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00CE:  BCF    03.5
00CF:  SWAPF  59,W
00D0:  MOVWF  77
00D1:  MOVLW  F0
00D2:  ANDWF  77,F
00D3:  MOVF   77,W
00D4:  IORWF  58,W
00D5:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
00A7:  MOVF   08,W
00A8:  MOVWF  77
00A9:  SWAPF  08,W
00AA:  ANDLW  0F
00AB:  MOVWF  78
....................   #endif 
00AC:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0098:  SWAPF  59,W
0099:  ANDLW  F0
009A:  MOVWF  77
009B:  MOVLW  0F
009C:  ANDWF  08,W
009D:  IORWF  77,W
009E:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
009F:  NOP
....................    lcd_output_enable(1); 
00A0:  BSF    08.0
....................    delay_us(2); 
00A1:  MOVLW  03
00A2:  MOVWF  77
00A3:  DECFSZ 77,F
00A4:  GOTO   0A3
....................    lcd_output_enable(0); 
00A5:  BCF    08.0
00A6:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00AD:  BSF    03.5
00AE:  BCF    08.0
....................    lcd_rs_tris(); 
00AF:  BCF    08.1
....................    lcd_rw_tris(); 
00B0:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00B1:  BCF    03.5
00B2:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
00D6:  MOVF   78,W
00D7:  MOVWF  58
00D8:  BTFSC  58.7
00D9:  GOTO   0B3
....................    lcd_output_rs(address); 
00DA:  BTFSS  56.0
00DB:  BCF    08.1
00DC:  BTFSC  56.0
00DD:  BSF    08.1
....................    delay_cycles(1); 
00DE:  NOP
....................    lcd_output_rw(0); 
00DF:  BCF    08.2
....................    delay_cycles(1); 
00E0:  NOP
....................    lcd_output_enable(0); 
00E1:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
00E2:  SWAPF  57,W
00E3:  MOVWF  58
00E4:  MOVLW  0F
00E5:  ANDWF  58,F
00E6:  MOVF   58,W
00E7:  MOVWF  59
00E8:  CALL   098
....................    lcd_send_nibble(n & 0xf); 
00E9:  MOVF   57,W
00EA:  ANDLW  0F
00EB:  MOVWF  58
00EC:  MOVWF  59
00ED:  CALL   098
00EE:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
00EF:  MOVLW  28
00F0:  MOVWF  45
00F1:  MOVLW  0C
00F2:  MOVWF  46
00F3:  MOVLW  01
00F4:  MOVWF  47
00F5:  MOVLW  06
00F6:  MOVWF  48
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
00F7:  BCF    08.0
....................    lcd_output_rs(0); 
00F8:  BCF    08.1
....................    lcd_output_rw(0); 
00F9:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00FA:  MOVLW  0F
00FB:  BSF    03.5
00FC:  ANDWF  08,W
00FD:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
00FE:  BCF    08.0
....................    lcd_rs_tris(); 
00FF:  BCF    08.1
....................    lcd_rw_tris(); 
0100:  BCF    08.2
....................  #endif 
....................      
....................    delay_ms(15); 
0101:  MOVLW  0F
0102:  BCF    03.5
0103:  MOVWF  52
0104:  CALL   084
....................    for(i=1;i<=3;++i) 
0105:  MOVLW  01
0106:  MOVWF  44
0107:  MOVF   44,W
0108:  SUBLW  03
0109:  BTFSS  03.0
010A:  GOTO   113
....................    { 
....................        lcd_send_nibble(3); 
010B:  MOVLW  03
010C:  MOVWF  59
010D:  CALL   098
....................        delay_ms(5); 
010E:  MOVLW  05
010F:  MOVWF  52
0110:  CALL   084
0111:  INCF   44,F
0112:  GOTO   107
....................    } 
....................     
....................    lcd_send_nibble(2); 
0113:  MOVLW  02
0114:  MOVWF  59
0115:  CALL   098
....................    delay_ms(5); 
0116:  MOVLW  05
0117:  MOVWF  52
0118:  CALL   084
....................    for(i=0;i<=3;++i) 
0119:  CLRF   44
011A:  MOVF   44,W
011B:  SUBLW  03
011C:  BTFSS  03.0
011D:  GOTO   12A
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
011E:  MOVLW  45
011F:  ADDWF  44,W
0120:  MOVWF  04
0121:  BCF    03.7
0122:  MOVF   00,W
0123:  MOVWF  49
0124:  CLRF   56
0125:  MOVF   49,W
0126:  MOVWF  57
0127:  CALL   0AD
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0128:  INCF   44,F
0129:  GOTO   11A
012A:  BSF    0A.3
012B:  BCF    0A.4
012C:  GOTO   041 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
043D:  DECFSZ 53,W
043E:  GOTO   440
043F:  GOTO   443
....................       address=LCD_LINE_TWO; 
0440:  MOVLW  40
0441:  MOVWF  54
0442:  GOTO   444
....................    else 
....................       address=0; 
0443:  CLRF   54
....................       
....................    address+=x-1; 
0444:  MOVLW  01
0445:  SUBWF  52,W
0446:  ADDWF  54,F
....................    lcd_send_byte(0,0x80|address); 
0447:  MOVF   54,W
0448:  IORLW  80
0449:  MOVWF  55
044A:  CLRF   56
044B:  MOVF   55,W
044C:  MOVWF  57
044D:  CALL   0AD
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
044E:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
044F:  MOVF   51,W
0450:  XORLW  07
0451:  BTFSC  03.2
0452:  GOTO   45D
0453:  XORLW  0B
0454:  BTFSC  03.2
0455:  GOTO   462
0456:  XORLW  06
0457:  BTFSC  03.2
0458:  GOTO   46A
0459:  XORLW  02
045A:  BTFSC  03.2
045B:  GOTO   470
045C:  GOTO   475
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
045D:  MOVLW  01
045E:  MOVWF  52
045F:  MOVWF  53
0460:  CALL   43D
0461:  GOTO   47A
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0462:  CLRF   56
0463:  MOVLW  01
0464:  MOVWF  57
0465:  CALL   0AD
....................                      delay_ms(2); 
0466:  MOVLW  02
0467:  MOVWF  52
0468:  CALL   084
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0469:  GOTO   47A
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
046A:  MOVLW  01
046B:  MOVWF  52
046C:  MOVLW  02
046D:  MOVWF  53
046E:  CALL   43D
046F:  GOTO   47A
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0470:  CLRF   56
0471:  MOVLW  10
0472:  MOVWF  57
0473:  CALL   0AD
0474:  GOTO   47A
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0475:  MOVLW  01
0476:  MOVWF  56
0477:  MOVF   51,W
0478:  MOVWF  57
0479:  CALL   0AD
....................      #endif 
....................    } 
047A:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... /* Prototipo de funciones */ 
.................... void escribir_i2c(); 
.................... void obtenerTemperatura(); 
.................... void leerEntrada(char* comando); 
.................... int analizaOpcion(char* comando); 
.................... int comparaStrings(char str1[], char str2[]); 
.................... int compareStrings(char* str1, char* str2); 
....................  
.................... int8 contador = 0; // contador principal 
.................... int8 countAux = 0; // contador auxiliar 
.................... char getch(void); 
.................... float valor_temperatura = 0.0; 
....................  
.................... // int comparaStrings(char str1[], char str2[]) 
.................... // { 
.................... //     for (int i = 0; i < strlen(str1); i++) { 
.................... //         if (str1[i] != str2[i]) 
.................... //             return 0; 
.................... //     } 
.................... //     return 1; 
.................... // } 
....................  
.................... int compareStrings(char* str1, char* str2) 
*
0244:  BSF    03.5
0245:  CLRF   51
.................... { 
....................     int i = 0; 
....................     while (str1[i] != '\0' && str2[i] != '\0') { 
0246:  MOVF   51,W
0247:  ADDWF  4D,W
0248:  MOVWF  04
0249:  BCF    03.7
024A:  BTFSC  4E.0
024B:  BSF    03.7
024C:  MOVF   00,F
024D:  BTFSC  03.2
024E:  GOTO   26F
024F:  MOVF   51,W
0250:  ADDWF  4F,W
0251:  MOVWF  04
0252:  BCF    03.7
0253:  BTFSC  50.0
0254:  BSF    03.7
0255:  MOVF   00,F
0256:  BTFSC  03.2
0257:  GOTO   26F
....................         if (str1[i] != str2[i]) { 
0258:  MOVF   51,W
0259:  ADDWF  4D,W
025A:  MOVWF  04
025B:  BCF    03.7
025C:  BTFSC  4E.0
025D:  BSF    03.7
025E:  MOVF   00,W
025F:  MOVWF  52
0260:  MOVF   51,W
0261:  ADDWF  4F,W
0262:  MOVWF  04
0263:  BCF    03.7
0264:  BTFSC  50.0
0265:  BSF    03.7
0266:  MOVF   00,W
0267:  SUBWF  52,W
0268:  BTFSC  03.2
0269:  GOTO   26D
....................             return 0; 
026A:  MOVLW  00
026B:  MOVWF  78
026C:  GOTO   286
....................         } 
....................         i++; 
026D:  INCF   51,F
026E:  GOTO   246
....................     } 
....................     if (str1[i] == '\0' && str2[i] == '\0') { 
026F:  MOVF   51,W
0270:  ADDWF  4D,W
0271:  MOVWF  04
0272:  BCF    03.7
0273:  BTFSC  4E.0
0274:  BSF    03.7
0275:  MOVF   00,F
0276:  BTFSS  03.2
0277:  GOTO   284
0278:  MOVF   51,W
0279:  ADDWF  4F,W
027A:  MOVWF  04
027B:  BCF    03.7
027C:  BTFSC  50.0
027D:  BSF    03.7
027E:  MOVF   00,F
027F:  BTFSS  03.2
0280:  GOTO   284
....................         return 1; 
0281:  MOVLW  01
0282:  MOVWF  78
0283:  GOTO   286
....................     } 
....................     return 0; 
0284:  MOVLW  00
0285:  MOVWF  78
0286:  BCF    03.5
0287:  RETURN
.................... } 
....................  
.................... void obtenerTemperatura() 
.................... { 
....................     set_adc_channel(0); 
*
04D1:  MOVLW  00
04D2:  MOVWF  78
04D3:  MOVF   1F,W
04D4:  ANDLW  C3
04D5:  IORWF  78,W
04D6:  MOVWF  1F
....................     delay_ms(10); 
04D7:  MOVLW  0A
04D8:  MOVWF  52
04D9:  CALL   084
....................     valor_temperatura = read_adc() * 2; 
04DA:  BSF    1F.1
04DB:  BTFSC  1F.1
04DC:  GOTO   4DB
04DD:  BCF    03.0
04DE:  RLF    1E,W
04DF:  CLRF   45
04E0:  MOVWF  44
*
04FD:  MOVF   7A,W
04FE:  MOVWF  2C
04FF:  MOVF   79,W
0500:  MOVWF  2B
0501:  MOVF   78,W
0502:  MOVWF  2A
0503:  MOVF   77,W
0504:  MOVWF  29
0505:  BSF    0A.3
0506:  BCF    0A.4
0507:  GOTO   0B0 (RETURN)
.................... } 
....................  
.................... void escribir_i2c() 
.................... { 
....................     i2c_start(); 
....................     i2c_write(0x42); // Direcion del esclavo 
....................     i2c_write(contador); // El dato a escribir 
....................     i2c_stop(); 
.................... } 
....................  
.................... void leerEntrada(char* comando) 
.................... { 
....................     char* ptr; 
....................     char ch; 
....................  
....................     ptr = comando; 
*
01DE:  MOVF   45,W
01DF:  MOVWF  47
01E0:  MOVF   44,W
01E1:  MOVWF  46
....................     printf("Ingrese comando: \n\r"); 
01E2:  MOVLW  04
01E3:  BSF    03.6
01E4:  MOVWF  0D
01E5:  MOVLW  00
01E6:  MOVWF  0F
01E7:  BCF    03.6
01E8:  CALL   12D
....................  
....................     while ((ch = getchar()) != '\r') { 
01E9:  BTFSS  0C.5
01EA:  GOTO   1E9
01EB:  MOVF   1A,W
01EC:  MOVWF  48
01ED:  SUBLW  0D
01EE:  BTFSC  03.2
01EF:  GOTO   201
....................         printf("%c", ch); 
01F0:  MOVF   48,W
01F1:  BTFSS  0C.4
01F2:  GOTO   1F1
01F3:  MOVWF  19
....................         *ptr++ = (char)ch; 
01F4:  MOVF   47,W
01F5:  MOVWF  7A
01F6:  MOVF   46,W
01F7:  INCF   46,F
01F8:  BTFSC  03.2
01F9:  INCF   47,F
01FA:  MOVWF  04
01FB:  BCF    03.7
01FC:  BTFSC  7A.0
01FD:  BSF    03.7
01FE:  MOVF   48,W
01FF:  MOVWF  00
0200:  GOTO   1E9
....................     } 
....................     printf("\n\r"); 
0201:  MOVLW  0A
0202:  BTFSS  0C.4
0203:  GOTO   202
0204:  MOVWF  19
0205:  MOVLW  0D
0206:  BTFSS  0C.4
0207:  GOTO   206
0208:  MOVWF  19
....................     *ptr++ = 0; 
0209:  MOVF   47,W
020A:  MOVWF  7A
020B:  MOVF   46,W
020C:  INCF   46,F
020D:  BTFSC  03.2
020E:  INCF   47,F
020F:  MOVWF  04
0210:  BCF    03.7
0211:  BTFSC  7A.0
0212:  BSF    03.7
0213:  CLRF   00
....................  
....................     printf("The given string is : %s\n\r", comando); 
0214:  MOVLW  0E
0215:  BSF    03.6
0216:  MOVWF  0D
0217:  MOVLW  00
0218:  MOVWF  0F
0219:  BCF    03.0
021A:  MOVLW  16
021B:  BCF    03.6
021C:  MOVWF  49
021D:  CALL   185
021E:  MOVF   44,W
021F:  MOVWF  04
0220:  BCF    03.7
0221:  BTFSC  45.0
0222:  BSF    03.7
*
0239:  MOVLW  0A
023A:  BTFSS  0C.4
023B:  GOTO   23A
023C:  MOVWF  19
023D:  MOVLW  0D
023E:  BTFSS  0C.4
023F:  GOTO   23E
0240:  MOVWF  19
0241:  BSF    0A.3
0242:  BCF    0A.4
0243:  GOTO   05D (RETURN)
.................... } 
....................  
.................... int getCommand(char* entry) 
*
0288:  CLRF   6E
.................... { 
....................     char command[20]; 
....................     char parameter[20]; 
....................     int i = 0; 
....................     char *temperaturaString = "temperatura", 
0289:  MOVLW  74
028A:  BSF    03.5
028B:  MOVWF  20
028C:  MOVLW  65
028D:  MOVWF  21
028E:  MOVLW  6D
028F:  MOVWF  22
0290:  MOVLW  70
0291:  MOVWF  23
0292:  MOVLW  65
0293:  MOVWF  24
0294:  MOVLW  72
0295:  MOVWF  25
0296:  MOVLW  61
0297:  MOVWF  26
0298:  MOVLW  74
0299:  MOVWF  27
029A:  MOVLW  75
029B:  MOVWF  28
029C:  MOVLW  72
029D:  MOVWF  29
029E:  MOVLW  61
029F:  MOVWF  2A
02A0:  CLRF   2B
02A1:  CLRF   70
02A2:  MOVLW  A0
02A3:  BCF    03.5
02A4:  MOVWF  6F
....................          *pwm = "pwm", 
02A5:  MOVLW  70
02A6:  MOVWF  73
02A7:  MOVLW  77
02A8:  MOVWF  74
02A9:  MOVLW  6D
02AA:  MOVWF  75
02AB:  CLRF   76
02AC:  CLRF   72
02AD:  MOVLW  73
02AE:  MOVWF  71
....................          *motor = "motor", 
02AF:  MOVLW  6D
02B0:  BSF    03.5
02B1:  MOVWF  2C
02B2:  MOVLW  6F
02B3:  MOVWF  2D
02B4:  MOVLW  74
02B5:  MOVWF  2E
02B6:  MOVLW  6F
02B7:  MOVWF  2F
02B8:  MOVLW  72
02B9:  MOVWF  30
02BA:  CLRF   31
02BB:  CLRF   7C
02BC:  MOVLW  AC
02BD:  MOVWF  7B
....................          *leds = "leds", 
02BE:  MOVLW  6C
02BF:  MOVWF  32
02C0:  MOVLW  65
02C1:  MOVWF  33
02C2:  MOVLW  64
02C3:  MOVWF  34
02C4:  MOVLW  73
02C5:  MOVWF  35
02C6:  CLRF   36
02C7:  CLRF   7E
02C8:  MOVLW  B2
02C9:  MOVWF  7D
....................          *offStr = "off", 
02CA:  MOVLW  6F
02CB:  MOVWF  39
02CC:  MOVLW  66
02CD:  MOVWF  3A
02CE:  MOVWF  3B
02CF:  CLRF   3C
02D0:  CLRF   38
02D1:  MOVLW  B9
02D2:  MOVWF  37
....................          *onStr = "on"; 
02D3:  MOVLW  6F
02D4:  MOVWF  3F
02D5:  MOVLW  6E
02D6:  MOVWF  40
02D7:  CLRF   41
02D8:  CLRF   3E
02D9:  MOVLW  BF
02DA:  MOVWF  3D
....................  
....................     while (entry[i] != ' ' && entry[i] != '\0') { 
02DB:  BCF    03.5
02DC:  MOVF   6E,W
02DD:  ADDWF  44,W
02DE:  MOVWF  04
02DF:  BCF    03.7
02E0:  BTFSC  45.0
02E1:  BSF    03.7
02E2:  MOVF   00,W
02E3:  SUBLW  20
02E4:  BTFSC  03.2
02E5:  GOTO   30E
02E6:  MOVF   6E,W
02E7:  ADDWF  44,W
02E8:  MOVWF  04
02E9:  BCF    03.7
02EA:  BTFSC  45.0
02EB:  BSF    03.7
02EC:  MOVF   00,F
02ED:  BTFSC  03.2
02EE:  GOTO   30E
....................         command[i] = entry[i]; 
02EF:  MOVLW  46
02F0:  ADDWF  6E,W
02F1:  MOVWF  78
02F2:  CLRF   7A
02F3:  BTFSC  03.0
02F4:  INCF   7A,F
02F5:  MOVF   78,W
02F6:  BSF    03.5
02F7:  MOVWF  43
02F8:  MOVF   7A,W
02F9:  MOVWF  44
02FA:  BCF    03.5
02FB:  MOVF   6E,W
02FC:  ADDWF  44,W
02FD:  MOVWF  04
02FE:  BCF    03.7
02FF:  BTFSC  45.0
0300:  BSF    03.7
0301:  MOVF   00,W
0302:  BSF    03.5
0303:  MOVWF  45
0304:  MOVF   43,W
0305:  MOVWF  04
0306:  BCF    03.7
0307:  BTFSC  44.0
0308:  BSF    03.7
0309:  MOVF   45,W
030A:  MOVWF  00
....................         i++; 
030B:  BCF    03.5
030C:  INCF   6E,F
030D:  GOTO   2DC
....................     } 
....................     command[i] = '\0'; 
030E:  MOVLW  46
030F:  ADDWF  6E,W
0310:  MOVWF  04
0311:  BCF    03.7
0312:  CLRF   00
....................     if (entry[i] == ' ') { 
0313:  MOVF   6E,W
0314:  ADDWF  44,W
0315:  MOVWF  04
0316:  BCF    03.7
0317:  BTFSC  45.0
0318:  BSF    03.7
0319:  MOVF   00,W
031A:  SUBLW  20
031B:  BTFSC  03.2
....................         i++; 
031C:  INCF   6E,F
....................     } 
....................     int j = 0; 
031D:  BSF    03.5
031E:  CLRF   42
....................     while (entry[i] != '\0') { 
031F:  BCF    03.5
0320:  MOVF   6E,W
0321:  ADDWF  44,W
0322:  MOVWF  04
0323:  BCF    03.7
0324:  BTFSC  45.0
0325:  BSF    03.7
0326:  MOVF   00,F
0327:  BTFSC  03.2
0328:  GOTO   34B
....................         parameter[j] = entry[i]; 
0329:  MOVLW  5A
032A:  BSF    03.5
032B:  ADDWF  42,W
032C:  MOVWF  78
032D:  CLRF   7A
032E:  BTFSC  03.0
032F:  INCF   7A,F
0330:  MOVF   78,W
0331:  MOVWF  43
0332:  MOVF   7A,W
0333:  MOVWF  44
0334:  BCF    03.5
0335:  MOVF   6E,W
0336:  ADDWF  44,W
0337:  MOVWF  04
0338:  BCF    03.7
0339:  BTFSC  45.0
033A:  BSF    03.7
033B:  MOVF   00,W
033C:  BSF    03.5
033D:  MOVWF  45
033E:  MOVF   43,W
033F:  MOVWF  04
0340:  BCF    03.7
0341:  BTFSC  44.0
0342:  BSF    03.7
0343:  MOVF   45,W
0344:  MOVWF  00
....................         i++; 
0345:  BCF    03.5
0346:  INCF   6E,F
....................         j++; 
0347:  BSF    03.5
0348:  INCF   42,F
0349:  GOTO   31F
034A:  BCF    03.5
....................     } 
....................     parameter[j] = '\0'; 
034B:  MOVLW  5A
034C:  BSF    03.5
034D:  ADDWF  42,W
034E:  MOVWF  04
034F:  BCF    03.7
0350:  CLRF   00
....................  
....................     if (compareStrings(command, temperaturaString)) { 
0351:  CLRF   4E
0352:  MOVLW  46
0353:  MOVWF  4D
0354:  MOVF   70,W
0355:  MOVWF  50
0356:  BCF    03.5
0357:  MOVF   6F,W
0358:  BSF    03.5
0359:  MOVWF  4F
035A:  BCF    03.5
035B:  CALL   244
035C:  MOVF   78,F
035D:  BTFSC  03.2
035E:  GOTO   363
....................         return 1; 
035F:  MOVLW  01
0360:  MOVWF  78
0361:  GOTO   3C8
....................     } else if (compareStrings(command, motor)) { 
0362:  GOTO   3C6
0363:  BSF    03.5
0364:  CLRF   4E
0365:  MOVLW  46
0366:  MOVWF  4D
0367:  MOVF   7C,W
0368:  MOVWF  50
0369:  MOVF   7B,W
036A:  MOVWF  4F
036B:  BCF    03.5
036C:  CALL   244
036D:  MOVF   78,F
036E:  BTFSC  03.2
036F:  GOTO   395
....................         if (compareStrings(parameter, onStr)) { 
0370:  BSF    03.5
0371:  CLRF   4E
0372:  MOVLW  5A
0373:  MOVWF  4D
0374:  MOVF   3E,W
0375:  MOVWF  50
0376:  MOVF   3D,W
0377:  MOVWF  4F
0378:  BCF    03.5
0379:  CALL   244
037A:  MOVF   78,F
037B:  BTFSC  03.2
037C:  GOTO   381
....................             return 2; 
037D:  MOVLW  02
037E:  MOVWF  78
037F:  GOTO   3C8
....................         } else if (compareStrings(parameter, offStr)) { 
0380:  GOTO   391
0381:  BSF    03.5
0382:  CLRF   4E
0383:  MOVLW  5A
0384:  MOVWF  4D
0385:  MOVF   38,W
0386:  MOVWF  50
0387:  MOVF   37,W
0388:  MOVWF  4F
0389:  BCF    03.5
038A:  CALL   244
038B:  MOVF   78,F
038C:  BTFSC  03.2
038D:  GOTO   391
....................             return 3; 
038E:  MOVLW  03
038F:  MOVWF  78
0390:  GOTO   3C8
....................         } 
....................         return -1; 
0391:  MOVLW  FF
0392:  MOVWF  78
0393:  GOTO   3C8
....................     } else if (compareStrings(command, leds)) { 
0394:  GOTO   3C6
0395:  BSF    03.5
0396:  CLRF   4E
0397:  MOVLW  46
0398:  MOVWF  4D
0399:  MOVF   7E,W
039A:  MOVWF  50
039B:  MOVF   7D,W
039C:  MOVWF  4F
039D:  BCF    03.5
039E:  CALL   244
039F:  MOVF   78,F
03A0:  BTFSC  03.2
03A1:  GOTO   3C6
....................         if (compareStrings(parameter, onStr)) { 
03A2:  BSF    03.5
03A3:  CLRF   4E
03A4:  MOVLW  5A
03A5:  MOVWF  4D
03A6:  MOVF   3E,W
03A7:  MOVWF  50
03A8:  MOVF   3D,W
03A9:  MOVWF  4F
03AA:  BCF    03.5
03AB:  CALL   244
03AC:  MOVF   78,F
03AD:  BTFSC  03.2
03AE:  GOTO   3B3
....................             return 4; 
03AF:  MOVLW  04
03B0:  MOVWF  78
03B1:  GOTO   3C8
....................         } else if (compareStrings(parameter, offStr)) { 
03B2:  GOTO   3C3
03B3:  BSF    03.5
03B4:  CLRF   4E
03B5:  MOVLW  5A
03B6:  MOVWF  4D
03B7:  MOVF   38,W
03B8:  MOVWF  50
03B9:  MOVF   37,W
03BA:  MOVWF  4F
03BB:  BCF    03.5
03BC:  CALL   244
03BD:  MOVF   78,F
03BE:  BTFSC  03.2
03BF:  GOTO   3C3
....................             return 5; 
03C0:  MOVLW  05
03C1:  MOVWF  78
03C2:  GOTO   3C8
....................         } 
....................         return -1; 
03C3:  MOVLW  FF
03C4:  MOVWF  78
03C5:  GOTO   3C8
....................     } 
....................  
....................     return -1; 
03C6:  MOVLW  FF
03C7:  MOVWF  78
03C8:  BSF    0A.3
03C9:  BCF    0A.4
03CA:  GOTO   063 (RETURN)
.................... } 
....................  
.................... int main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  BSF    03.5
0804:  BSF    03.6
0805:  BSF    07.3
0806:  MOVLW  08
0807:  BCF    03.6
0808:  MOVWF  19
0809:  MOVLW  02
080A:  MOVWF  1A
080B:  MOVLW  A6
080C:  MOVWF  18
080D:  MOVLW  90
080E:  BCF    03.5
080F:  MOVWF  18
0810:  MOVLW  FF
0811:  MOVWF  26
0812:  BSF    26.3
0813:  MOVF   26,W
0814:  BSF    03.5
0815:  MOVWF  07
0816:  BCF    03.5
0817:  BSF    26.4
0818:  MOVF   26,W
0819:  BSF    03.5
081A:  MOVWF  07
081B:  MOVLW  31
081C:  MOVWF  13
081D:  MOVLW  28
081E:  BCF    03.5
081F:  MOVWF  14
0820:  BSF    03.5
0821:  BSF    14.7
0822:  BCF    14.6
0823:  BCF    03.5
0824:  CLRF   27
0825:  CLRF   28
0826:  CLRF   2C
0827:  CLRF   2B
0828:  CLRF   2A
0829:  CLRF   29
082A:  CLRF   2E
082B:  CLRF   2D
082C:  BSF    03.5
082D:  BSF    03.6
082E:  MOVF   09,W
082F:  ANDLW  C0
0830:  MOVWF  09
0831:  BCF    03.6
0832:  BCF    1F.4
0833:  BCF    1F.5
0834:  MOVLW  00
0835:  BSF    03.6
0836:  MOVWF  08
0837:  BCF    03.5
0838:  CLRF   07
0839:  CLRF   08
083A:  CLRF   09
083B:  BCF    03.7
.................... { 
....................     /* Configuracion */ 
....................     lcd_init(); 
*
083F:  BCF    0A.3
0840:  GOTO   0EF
0841:  BSF    0A.3
....................     // enable_interrupts(INT_RB); 
....................     enable_interrupts(GLOBAL); 
0842:  MOVLW  C0
0843:  IORWF  0B,F
....................     Setup_port_a(ALL_ANALOG); 
0844:  BSF    03.5
0845:  BSF    03.6
0846:  MOVF   09,W
0847:  ANDLW  C0
0848:  IORLW  1F
0849:  MOVWF  09
084A:  BCF    03.6
084B:  BCF    1F.4
084C:  BCF    1F.5
084D:  MOVLW  FF
084E:  BSF    03.6
084F:  MOVWF  08
....................     Setup_adc(ADC_CLOCK_INTERNAL); 
0850:  BCF    03.5
0851:  BCF    03.6
0852:  BSF    1F.6
0853:  BSF    1F.7
0854:  BSF    03.5
0855:  BCF    1F.7
0856:  BCF    03.5
0857:  BSF    1F.0
....................  
....................     while (TRUE) { 
....................         char comando[20]; 
....................         leerEntrada(&comando); 
0858:  CLRF   45
0859:  MOVLW  2F
085A:  MOVWF  44
085B:  BCF    0A.3
085C:  GOTO   1DE
085D:  BSF    0A.3
....................         // int opcion = analizaOpcion(comando); 
....................         int opcion = getCommand(comando); 
085E:  CLRF   45
085F:  MOVLW  2F
0860:  MOVWF  44
0861:  BCF    0A.3
0862:  GOTO   288
0863:  BSF    0A.3
0864:  MOVF   78,W
0865:  MOVWF  43
....................         printf("Opcion: %d\n\r", opcion); 
0866:  MOVLW  1C
0867:  BSF    03.6
0868:  MOVWF  0D
0869:  MOVLW  00
086A:  MOVWF  0F
086B:  BCF    03.0
086C:  MOVLW  08
086D:  BCF    03.6
086E:  MOVWF  49
086F:  BCF    0A.3
0870:  CALL   185
0871:  BSF    0A.3
0872:  MOVF   43,W
0873:  MOVWF  44
0874:  MOVLW  18
0875:  MOVWF  45
0876:  BCF    0A.3
0877:  GOTO   3E0
0878:  BSF    0A.3
0879:  MOVLW  0A
087A:  BTFSS  0C.4
087B:  GOTO   07A
087C:  MOVWF  19
087D:  MOVLW  0D
087E:  BTFSS  0C.4
087F:  GOTO   07E
0880:  MOVWF  19
....................         switch (opcion) { 
0881:  MOVF   43,W
0882:  BTFSC  03.2
0883:  GOTO   094
0884:  XORLW  01
0885:  BTFSC  03.2
0886:  GOTO   0A9
0887:  XORLW  03
0888:  BTFSC  03.2
0889:  GOTO   0E2
088A:  XORLW  01
088B:  BTFSC  03.2
088C:  GOTO   0FC
088D:  XORLW  07
088E:  BTFSC  03.2
088F:  GOTO   116
0890:  XORLW  01
0891:  BTFSC  03.2
0892:  GOTO   130
0893:  GOTO   14A
....................         case 0: 
....................             lcd_putc('\f'); 
0894:  MOVLW  0C
0895:  MOVWF  51
0896:  BCF    0A.3
0897:  CALL   44F
0898:  BSF    0A.3
....................             lcd_gotoxy(0, 1); 
0899:  CLRF   52
089A:  MOVLW  01
089B:  MOVWF  53
089C:  BCF    0A.3
089D:  CALL   43D
089E:  BSF    0A.3
....................             printf(lcd_putc, " Esperando comando..."); 
089F:  MOVLW  23
08A0:  BSF    03.6
08A1:  MOVWF  0D
08A2:  MOVLW  00
08A3:  MOVWF  0F
08A4:  BCF    0A.3
08A5:  BCF    03.6
08A6:  CALL   47B
08A7:  BSF    0A.3
....................             break; 
08A8:  GOTO   154
....................         // Temperatura 
....................         case 1: 
....................             lcd_putc('\f'); 
08A9:  MOVLW  0C
08AA:  MOVWF  51
08AB:  BCF    0A.3
08AC:  CALL   44F
08AD:  BSF    0A.3
....................             obtenerTemperatura(); 
08AE:  BCF    0A.3
08AF:  GOTO   4D1
08B0:  BSF    0A.3
....................             lcd_gotoxy(0, 1); 
08B1:  CLRF   52
08B2:  MOVLW  01
08B3:  MOVWF  53
08B4:  BCF    0A.3
08B5:  CALL   43D
08B6:  BSF    0A.3
....................             printf(lcd_putc, " Temp.: %f C", valor_temperatura); 
08B7:  MOVLW  2E
08B8:  BSF    03.6
08B9:  MOVWF  0D
08BA:  MOVLW  00
08BB:  MOVWF  0F
08BC:  BCF    03.0
08BD:  MOVLW  08
08BE:  BCF    03.6
08BF:  MOVWF  44
08C0:  BCF    0A.3
08C1:  GOTO   508
08C2:  BSF    0A.3
08C3:  MOVLW  89
08C4:  MOVWF  04
08C5:  MOVF   2C,W
08C6:  MOVWF  47
08C7:  MOVF   2B,W
08C8:  MOVWF  46
08C9:  MOVF   2A,W
08CA:  MOVWF  45
08CB:  MOVF   29,W
08CC:  MOVWF  44
08CD:  MOVLW  02
08CE:  MOVWF  48
08CF:  BCF    0A.3
08D0:  GOTO   5B0
08D1:  BSF    0A.3
08D2:  MOVLW  20
08D3:  MOVWF  51
08D4:  BCF    0A.3
08D5:  CALL   44F
08D6:  BSF    0A.3
08D7:  MOVLW  43
08D8:  MOVWF  51
08D9:  BCF    0A.3
08DA:  CALL   44F
08DB:  BSF    0A.3
....................             delay_ms(200); 
08DC:  MOVLW  C8
08DD:  MOVWF  52
08DE:  BCF    0A.3
08DF:  CALL   084
08E0:  BSF    0A.3
....................             break; 
08E1:  GOTO   154
....................  
....................         // Motor on 
....................         case 2: 
....................             lcd_putc('\f'); 
08E2:  MOVLW  0C
08E3:  MOVWF  51
08E4:  BCF    0A.3
08E5:  CALL   44F
08E6:  BSF    0A.3
....................             lcd_gotoxy(0, 1); 
08E7:  CLRF   52
08E8:  MOVLW  01
08E9:  MOVWF  53
08EA:  BCF    0A.3
08EB:  CALL   43D
08EC:  BSF    0A.3
....................             printf(lcd_putc, " Motor ON"); 
08ED:  MOVLW  35
08EE:  BSF    03.6
08EF:  MOVWF  0D
08F0:  MOVLW  00
08F1:  MOVWF  0F
08F2:  BCF    0A.3
08F3:  BCF    03.6
08F4:  CALL   47B
08F5:  BSF    0A.3
....................             delay_ms(200); 
08F6:  MOVLW  C8
08F7:  MOVWF  52
08F8:  BCF    0A.3
08F9:  CALL   084
08FA:  BSF    0A.3
....................             break; 
08FB:  GOTO   154
....................  
....................         // Motor off 
....................         case 3: 
....................             lcd_putc('\f'); 
08FC:  MOVLW  0C
08FD:  MOVWF  51
08FE:  BCF    0A.3
08FF:  CALL   44F
0900:  BSF    0A.3
....................             lcd_gotoxy(0, 1); 
0901:  CLRF   52
0902:  MOVLW  01
0903:  MOVWF  53
0904:  BCF    0A.3
0905:  CALL   43D
0906:  BSF    0A.3
....................             printf(lcd_putc, " Motor OFF"); 
0907:  MOVLW  3A
0908:  BSF    03.6
0909:  MOVWF  0D
090A:  MOVLW  00
090B:  MOVWF  0F
090C:  BCF    0A.3
090D:  BCF    03.6
090E:  CALL   47B
090F:  BSF    0A.3
....................             delay_ms(200); 
0910:  MOVLW  C8
0911:  MOVWF  52
0912:  BCF    0A.3
0913:  CALL   084
0914:  BSF    0A.3
....................             break; 
0915:  GOTO   154
....................  
....................         // Leds on 
....................         case 4: 
....................             lcd_putc('\f'); 
0916:  MOVLW  0C
0917:  MOVWF  51
0918:  BCF    0A.3
0919:  CALL   44F
091A:  BSF    0A.3
....................             lcd_gotoxy(0, 1); 
091B:  CLRF   52
091C:  MOVLW  01
091D:  MOVWF  53
091E:  BCF    0A.3
091F:  CALL   43D
0920:  BSF    0A.3
....................             printf(lcd_putc, " Leds ON"); 
0921:  MOVLW  40
0922:  BSF    03.6
0923:  MOVWF  0D
0924:  MOVLW  00
0925:  MOVWF  0F
0926:  BCF    0A.3
0927:  BCF    03.6
0928:  CALL   47B
0929:  BSF    0A.3
....................             delay_ms(200); 
092A:  MOVLW  C8
092B:  MOVWF  52
092C:  BCF    0A.3
092D:  CALL   084
092E:  BSF    0A.3
....................             break; 
092F:  GOTO   154
....................  
....................         // Leds off 
....................         case 5: 
....................             lcd_putc('\f'); 
0930:  MOVLW  0C
0931:  MOVWF  51
0932:  BCF    0A.3
0933:  CALL   44F
0934:  BSF    0A.3
....................             lcd_gotoxy(0, 1); 
0935:  CLRF   52
0936:  MOVLW  01
0937:  MOVWF  53
0938:  BCF    0A.3
0939:  CALL   43D
093A:  BSF    0A.3
....................             printf(lcd_putc, " Leds OFF"); 
093B:  MOVLW  45
093C:  BSF    03.6
093D:  MOVWF  0D
093E:  MOVLW  00
093F:  MOVWF  0F
0940:  BCF    0A.3
0941:  BCF    03.6
0942:  CALL   47B
0943:  BSF    0A.3
....................             delay_ms(200); 
0944:  MOVLW  C8
0945:  MOVWF  52
0946:  BCF    0A.3
0947:  CALL   084
0948:  BSF    0A.3
....................             break; 
0949:  GOTO   154
....................  
....................         default: 
....................             printf("Ups, intenta de nuevo un comando invalido\n\rAlgunos comandos validos son:\n\rmotor on, pwm=50, leds off, temperatura\n\r"); 
094A:  MOVLW  4A
094B:  BSF    03.6
094C:  MOVWF  0D
094D:  MOVLW  00
094E:  MOVWF  0F
094F:  BCF    0A.3
0950:  BCF    03.6
0951:  CALL   12D
0952:  BSF    0A.3
....................             break; 
0953:  GOTO   154
....................         } 
0954:  GOTO   058
....................     } 
....................  
....................     return 0; 
0955:  MOVLW  00
0956:  MOVWF  78
.................... } 
0957:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
