CCS PCM C Compiler, Version 5.076, 2401               10-Jun-23 22:58

               Filename:   C:\Users\aaldi\OneDrive - UNIVERSIDAD NACIONAL AUTÓNOMA DE MÉXICO\school\8th-semester\Micro-Tareas\ProyectoFinal\PuertoSerial\PuertoSerial.lst

               ROM used:   1627 words (20%)
                           Largest free fragment is 2048
               RAM used:   41 (11%) at main() level
                           88 (24%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   5B1
0003:  NOP
.................... #include <16f887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0004:  DATA 49,37
0005:  DATA 67,39
0006:  DATA E5,39
0007:  DATA 65,10
0008:  DATA E3,37
0009:  DATA ED,30
000A:  DATA 6E,32
000B:  DATA 6F,1D
000C:  DATA 20,05
000D:  DATA 0D,00
000E:  DATA 54,34
000F:  DATA 65,10
0010:  DATA E7,34
0011:  DATA F6,32
0012:  DATA 6E,10
0013:  DATA 73,3A
0014:  DATA F2,34
0015:  DATA EE,33
0016:  DATA A0,34
0017:  DATA 73,10
0018:  DATA 3A,10
0019:  DATA A5,39
001A:  DATA 8A,06
001B:  DATA 00,00
001C:  RETLW  55
001D:  RETLW  70
001E:  RETLW  73
001F:  RETLW  2C
0020:  RETLW  20
0021:  RETLW  69
0022:  RETLW  6E
0023:  RETLW  74
0024:  RETLW  65
0025:  RETLW  6E
0026:  RETLW  74
0027:  RETLW  61
0028:  RETLW  20
0029:  RETLW  64
002A:  RETLW  65
002B:  RETLW  20
002C:  RETLW  6E
002D:  RETLW  75
002E:  RETLW  65
002F:  RETLW  76
0030:  RETLW  6F
0031:  RETLW  20
0032:  RETLW  75
0033:  RETLW  6E
0034:  RETLW  20
0035:  RETLW  63
0036:  RETLW  6F
0037:  RETLW  6D
0038:  RETLW  61
0039:  RETLW  6E
003A:  RETLW  64
003B:  RETLW  6F
003C:  RETLW  20
003D:  RETLW  76
003E:  RETLW  E1
003F:  RETLW  6C
0040:  RETLW  69
0041:  RETLW  64
0042:  RETLW  6F
0043:  RETLW  0A
0044:  RETLW  0D
0045:  RETLW  41
0046:  RETLW  6C
0047:  RETLW  67
0048:  RETLW  75
0049:  RETLW  6E
004A:  RETLW  6F
004B:  RETLW  73
004C:  RETLW  20
004D:  RETLW  63
004E:  RETLW  6F
004F:  RETLW  6D
0050:  RETLW  61
0051:  RETLW  6E
0052:  RETLW  64
0053:  RETLW  6F
0054:  RETLW  73
0055:  RETLW  20
0056:  RETLW  76
0057:  RETLW  61
0058:  RETLW  6C
0059:  RETLW  69
005A:  RETLW  64
005B:  RETLW  6F
005C:  RETLW  73
005D:  RETLW  20
005E:  RETLW  73
005F:  RETLW  6F
0060:  RETLW  6E
0061:  RETLW  3A
0062:  RETLW  0A
0063:  RETLW  0D
0064:  RETLW  20
0065:  RETLW  6D
0066:  RETLW  6F
0067:  RETLW  74
0068:  RETLW  6F
0069:  RETLW  72
006A:  RETLW  20
006B:  RETLW  6F
006C:  RETLW  6E
006D:  RETLW  2C
006E:  RETLW  20
006F:  RETLW  70
0070:  RETLW  77
0071:  RETLW  6D
0072:  RETLW  3D
0073:  RETLW  35
0074:  RETLW  30
0075:  RETLW  2C
0076:  RETLW  20
0077:  RETLW  6C
0078:  RETLW  65
0079:  RETLW  64
007A:  RETLW  73
007B:  RETLW  20
007C:  RETLW  6F
007D:  RETLW  66
007E:  RETLW  66
007F:  RETLW  2C
0080:  RETLW  20
0081:  RETLW  74
0082:  RETLW  65
0083:  RETLW  6D
0084:  RETLW  70
0085:  RETLW  65
0086:  RETLW  72
0087:  RETLW  61
0088:  RETLW  74
0089:  RETLW  75
008A:  RETLW  72
008B:  RETLW  61
008C:  RETLW  0A
008D:  RETLW  0D
008E:  RETLW  00
008F:  DATA D4,32
0090:  DATA 6D,38
0091:  DATA 2E,1D
0092:  DATA A0,12
0093:  DATA 66,10
0094:  DATA 43,05
0095:  DATA 0D,00
*
0148:  BCF    03.6
0149:  MOVF   0B,W
014A:  MOVWF  49
014B:  BCF    0B.7
014C:  BSF    03.5
014D:  BSF    03.6
014E:  BSF    0C.7
014F:  BSF    0C.0
0150:  NOP
0151:  NOP
0152:  BCF    03.5
0153:  BCF    03.6
0154:  BTFSC  49.7
0155:  BSF    0B.7
0156:  BSF    03.6
0157:  MOVF   0C,W
0158:  ANDLW  7F
0159:  BTFSC  03.2
015A:  GOTO   19D
015B:  BCF    03.6
015C:  MOVWF  49
015D:  BSF    03.6
015E:  MOVF   0D,W
015F:  BCF    03.6
0160:  MOVWF  4A
0161:  BSF    03.6
0162:  MOVF   0F,W
0163:  BCF    03.6
0164:  MOVWF  4B
0165:  MOVF   49,W
0166:  BTFSS  0C.4
0167:  GOTO   166
0168:  MOVWF  19
0169:  MOVF   4A,W
016A:  BSF    03.6
016B:  MOVWF  0D
016C:  BCF    03.6
016D:  MOVF   4B,W
016E:  BSF    03.6
016F:  MOVWF  0F
0170:  BCF    03.6
0171:  MOVF   0B,W
0172:  MOVWF  4C
0173:  BCF    0B.7
0174:  BSF    03.5
0175:  BSF    03.6
0176:  BSF    0C.7
0177:  BSF    0C.0
0178:  NOP
0179:  NOP
017A:  BCF    03.5
017B:  BCF    03.6
017C:  BTFSC  4C.7
017D:  BSF    0B.7
017E:  BSF    03.6
017F:  RLF    0C,W
0180:  RLF    0E,W
0181:  ANDLW  7F
0182:  BTFSC  03.2
0183:  GOTO   19D
0184:  BCF    03.6
0185:  MOVWF  49
0186:  BSF    03.6
0187:  MOVF   0D,W
0188:  BCF    03.6
0189:  MOVWF  4A
018A:  BSF    03.6
018B:  MOVF   0F,W
018C:  BCF    03.6
018D:  MOVWF  4B
018E:  MOVF   49,W
018F:  BTFSS  0C.4
0190:  GOTO   18F
0191:  MOVWF  19
0192:  MOVF   4A,W
0193:  BSF    03.6
0194:  MOVWF  0D
0195:  BCF    03.6
0196:  MOVF   4B,W
0197:  BSF    03.6
0198:  MOVWF  0F
0199:  INCF   0D,F
019A:  BTFSC  03.2
019B:  INCF   0F,F
019C:  GOTO   148
*
01D2:  MOVF   0B,W
01D3:  MOVWF  4A
01D4:  BCF    0B.7
01D5:  BSF    03.5
01D6:  BSF    03.6
01D7:  BSF    0C.7
01D8:  BSF    0C.0
01D9:  NOP
01DA:  NOP
01DB:  BCF    03.5
01DC:  BCF    03.6
01DD:  BTFSC  4A.7
01DE:  BSF    0B.7
01DF:  BTFSC  03.0
01E0:  GOTO   20A
01E1:  BSF    03.6
01E2:  MOVF   0C,W
01E3:  ANDLW  7F
01E4:  BCF    03.6
01E5:  MOVWF  4A
01E6:  BSF    03.6
01E7:  MOVF   0D,W
01E8:  BCF    03.6
01E9:  MOVWF  4B
01EA:  BSF    03.6
01EB:  MOVF   0F,W
01EC:  BCF    03.6
01ED:  MOVWF  4C
01EE:  MOVF   4A,W
01EF:  BTFSS  0C.4
01F0:  GOTO   1EF
01F1:  MOVWF  19
01F2:  MOVF   4B,W
01F3:  BSF    03.6
01F4:  MOVWF  0D
01F5:  BCF    03.6
01F6:  MOVF   4C,W
01F7:  BSF    03.6
01F8:  MOVWF  0F
01F9:  BCF    03.6
01FA:  MOVF   0B,W
01FB:  MOVWF  4D
01FC:  BCF    0B.7
01FD:  BSF    03.5
01FE:  BSF    03.6
01FF:  BSF    0C.7
0200:  BSF    0C.0
0201:  NOP
0202:  NOP
0203:  BCF    03.5
0204:  BCF    03.6
0205:  BTFSC  4D.7
0206:  BSF    0B.7
0207:  DECFSZ 49,F
0208:  GOTO   20A
0209:  GOTO   22A
020A:  BSF    03.6
020B:  RLF    0C,W
020C:  RLF    0E,W
020D:  ANDLW  7F
020E:  BCF    03.6
020F:  MOVWF  4A
0210:  BSF    03.6
0211:  MOVF   0D,W
0212:  BCF    03.6
0213:  MOVWF  4B
0214:  BSF    03.6
0215:  MOVF   0F,W
0216:  BCF    03.6
0217:  MOVWF  4C
0218:  MOVF   4A,W
0219:  BTFSS  0C.4
021A:  GOTO   219
021B:  MOVWF  19
021C:  MOVF   4B,W
021D:  BSF    03.6
021E:  MOVWF  0D
021F:  BCF    03.6
0220:  MOVF   4C,W
0221:  BSF    03.6
0222:  MOVWF  0F
0223:  INCF   0D,F
0224:  BTFSC  03.2
0225:  INCF   0F,F
0226:  BCF    03.0
0227:  BCF    03.6
0228:  DECFSZ 49,F
0229:  GOTO   1D2
*
022F:  MOVF   00,F
0230:  BTFSC  03.2
0231:  GOTO   245
0232:  CLRF   4A
0233:  MOVF   04,W
0234:  MOVWF  49
0235:  BCF    4A.0
0236:  BTFSC  03.7
0237:  BSF    4A.0
0238:  MOVF   00,W
0239:  BTFSS  0C.4
023A:  GOTO   239
023B:  MOVWF  19
023C:  MOVF   49,W
023D:  MOVWF  04
023E:  BCF    03.7
023F:  BTFSC  4A.0
0240:  BSF    03.7
0241:  INCF   04,F
0242:  BTFSC  03.2
0243:  INCF   05,F
0244:  GOTO   22F
*
0312:  MOVF   0B,W
0313:  MOVWF  44
0314:  BCF    0B.7
0315:  BSF    03.5
0316:  BSF    03.6
0317:  BSF    0C.7
0318:  BSF    0C.0
0319:  NOP
031A:  NOP
031B:  BCF    03.5
031C:  BCF    03.6
031D:  BTFSC  44.7
031E:  BSF    0B.7
031F:  BSF    03.6
0320:  MOVF   0C,F
0321:  BTFSC  03.2
0322:  GOTO   33D
0323:  MOVF   0D,W
0324:  BCF    03.6
0325:  MOVWF  44
0326:  BSF    03.6
0327:  MOVF   0F,W
0328:  BCF    03.6
0329:  MOVWF  45
032A:  BSF    03.6
032B:  MOVF   0C,W
032C:  BCF    03.6
032D:  BTFSS  0C.4
032E:  GOTO   32D
032F:  MOVWF  19
0330:  MOVF   44,W
0331:  BSF    03.6
0332:  MOVWF  0D
0333:  BCF    03.6
0334:  MOVF   45,W
0335:  BSF    03.6
0336:  MOVWF  0F
0337:  INCF   0D,F
0338:  BTFSC  03.2
0339:  INCF   0F,F
033A:  BCF    03.6
033B:  GOTO   312
033C:  BSF    03.6
033D:  BCF    03.6
033E:  BCF    0A.3
033F:  BCF    0A.4
0340:  GOTO   62E (RETURN)
*
0351:  MOVLW  8E
0352:  MOVWF  77
0353:  MOVF   45,W
0354:  MOVWF  78
0355:  MOVF   44,W
0356:  MOVWF  79
0357:  CLRF   7A
0358:  MOVF   78,F
0359:  BTFSS  03.2
035A:  GOTO   365
035B:  MOVF   79,W
035C:  MOVWF  78
035D:  CLRF   79
035E:  MOVLW  08
035F:  SUBWF  77,F
0360:  MOVF   78,F
0361:  BTFSS  03.2
0362:  GOTO   365
0363:  CLRF   77
0364:  GOTO   36D
0365:  BCF    03.0
0366:  BTFSC  78.7
0367:  GOTO   36C
0368:  RLF    79,F
0369:  RLF    78,F
036A:  DECF   77,F
036B:  GOTO   365
036C:  BCF    78.7
*
03B6:  MOVF   0B,W
03B7:  MOVWF  45
03B8:  BCF    0B.7
03B9:  BSF    03.5
03BA:  BSF    03.6
03BB:  BSF    0C.7
03BC:  BSF    0C.0
03BD:  NOP
03BE:  NOP
03BF:  BCF    03.5
03C0:  BCF    03.6
03C1:  BTFSC  45.7
03C2:  BSF    0B.7
03C3:  BTFSC  03.0
03C4:  GOTO   3ED
03C5:  BSF    03.6
03C6:  MOVF   0C,W
03C7:  ANDLW  7F
03C8:  BCF    03.6
03C9:  MOVWF  45
03CA:  BSF    03.6
03CB:  MOVF   0D,W
03CC:  BCF    03.6
03CD:  MOVWF  46
03CE:  BSF    03.6
03CF:  MOVF   0F,W
03D0:  BCF    03.6
03D1:  MOVWF  47
03D2:  MOVF   45,W
03D3:  MOVWF  51
03D4:  CALL   38A
03D5:  MOVF   46,W
03D6:  BSF    03.6
03D7:  MOVWF  0D
03D8:  BCF    03.6
03D9:  MOVF   47,W
03DA:  BSF    03.6
03DB:  MOVWF  0F
03DC:  BCF    03.6
03DD:  MOVF   0B,W
03DE:  MOVWF  48
03DF:  BCF    0B.7
03E0:  BSF    03.5
03E1:  BSF    03.6
03E2:  BSF    0C.7
03E3:  BSF    0C.0
03E4:  NOP
03E5:  NOP
03E6:  BCF    03.5
03E7:  BCF    03.6
03E8:  BTFSC  48.7
03E9:  BSF    0B.7
03EA:  DECFSZ 44,F
03EB:  GOTO   3ED
03EC:  GOTO   40C
03ED:  BSF    03.6
03EE:  RLF    0C,W
03EF:  RLF    0E,W
03F0:  ANDLW  7F
03F1:  BCF    03.6
03F2:  MOVWF  45
03F3:  BSF    03.6
03F4:  MOVF   0D,W
03F5:  BCF    03.6
03F6:  MOVWF  46
03F7:  BSF    03.6
03F8:  MOVF   0F,W
03F9:  BCF    03.6
03FA:  MOVWF  47
03FB:  MOVF   45,W
03FC:  MOVWF  51
03FD:  CALL   38A
03FE:  MOVF   46,W
03FF:  BSF    03.6
0400:  MOVWF  0D
0401:  BCF    03.6
0402:  MOVF   47,W
0403:  BSF    03.6
0404:  MOVWF  0F
0405:  INCF   0D,F
0406:  BTFSC  03.2
0407:  INCF   0F,F
0408:  BCF    03.0
0409:  BCF    03.6
040A:  DECFSZ 44,F
040B:  GOTO   3B6
040C:  RETURN
040D:  BTFSC  03.1
040E:  GOTO   412
040F:  MOVLW  59
0410:  MOVWF  04
0411:  BCF    03.7
0412:  CLRF   77
0413:  CLRF   78
0414:  CLRF   79
0415:  CLRF   7A
0416:  CLRF   59
0417:  CLRF   5A
0418:  CLRF   5B
0419:  CLRF   5C
041A:  MOVF   58,W
041B:  IORWF  57,W
041C:  IORWF  56,W
041D:  IORWF  55,W
041E:  BTFSC  03.2
041F:  GOTO   450
0420:  MOVLW  20
0421:  MOVWF  5D
0422:  BCF    03.0
0423:  RLF    51,F
0424:  RLF    52,F
0425:  RLF    53,F
0426:  RLF    54,F
0427:  RLF    59,F
0428:  RLF    5A,F
0429:  RLF    5B,F
042A:  RLF    5C,F
042B:  MOVF   58,W
042C:  SUBWF  5C,W
042D:  BTFSS  03.2
042E:  GOTO   439
042F:  MOVF   57,W
0430:  SUBWF  5B,W
0431:  BTFSS  03.2
0432:  GOTO   439
0433:  MOVF   56,W
0434:  SUBWF  5A,W
0435:  BTFSS  03.2
0436:  GOTO   439
0437:  MOVF   55,W
0438:  SUBWF  59,W
0439:  BTFSS  03.0
043A:  GOTO   44A
043B:  MOVF   55,W
043C:  SUBWF  59,F
043D:  MOVF   56,W
043E:  BTFSS  03.0
043F:  INCFSZ 56,W
0440:  SUBWF  5A,F
0441:  MOVF   57,W
0442:  BTFSS  03.0
0443:  INCFSZ 57,W
0444:  SUBWF  5B,F
0445:  MOVF   58,W
0446:  BTFSS  03.0
0447:  INCFSZ 58,W
0448:  SUBWF  5C,F
0449:  BSF    03.0
044A:  RLF    77,F
044B:  RLF    78,F
044C:  RLF    79,F
044D:  RLF    7A,F
044E:  DECFSZ 5D,F
044F:  GOTO   422
0450:  MOVF   59,W
0451:  MOVWF  00
0452:  INCF   04,F
0453:  MOVF   5A,W
0454:  MOVWF  00
0455:  INCF   04,F
0456:  MOVF   5B,W
0457:  MOVWF  00
0458:  INCF   04,F
0459:  MOVF   5C,W
045A:  MOVWF  00
045B:  RETURN
045C:  MOVF   04,W
045D:  MOVWF  49
045E:  MOVF   48,W
045F:  MOVWF  4B
0460:  BTFSC  03.2
0461:  GOTO   4EE
0462:  MOVF   47,W
0463:  MOVWF  54
0464:  MOVF   46,W
0465:  MOVWF  53
0466:  MOVF   45,W
0467:  MOVWF  52
0468:  MOVF   44,W
0469:  MOVWF  51
046A:  CLRF   58
046B:  CLRF   57
046C:  MOVLW  20
046D:  MOVWF  56
046E:  MOVLW  82
046F:  MOVWF  55
0470:  MOVF   51,W
0471:  BTFSC  03.2
0472:  GOTO   4E0
0473:  MOVWF  59
0474:  MOVF   55,W
0475:  BTFSC  03.2
0476:  GOTO   4E0
0477:  ADDWF  59,F
0478:  BTFSC  03.0
0479:  GOTO   481
047A:  MOVLW  7F
047B:  SUBWF  59,F
047C:  BTFSS  03.0
047D:  GOTO   4E0
047E:  BTFSC  03.2
047F:  GOTO   4E0
0480:  GOTO   485
0481:  MOVLW  81
0482:  ADDWF  59,F
0483:  BTFSC  03.0
0484:  GOTO   4E0
0485:  MOVF   59,W
0486:  MOVWF  77
0487:  CLRF   78
0488:  CLRF   79
0489:  CLRF   7A
048A:  MOVF   52,W
048B:  MOVWF  5D
048C:  BSF    5D.7
048D:  MOVF   53,W
048E:  MOVWF  5C
048F:  MOVF   54,W
0490:  MOVWF  5B
0491:  MOVLW  18
0492:  MOVWF  59
0493:  CLRF   5A
0494:  BTFSS  5B.0
0495:  GOTO   4AE
0496:  MOVF   58,W
0497:  ADDWF  7A,F
0498:  BTFSS  03.0
0499:  GOTO   4A0
049A:  INCF   79,F
049B:  BTFSS  03.2
049C:  GOTO   4A0
049D:  INCF   78,F
049E:  BTFSC  03.2
049F:  BSF    5A.7
04A0:  MOVF   57,W
04A1:  ADDWF  79,F
04A2:  BTFSS  03.0
04A3:  GOTO   4A7
04A4:  INCF   78,F
04A5:  BTFSC  03.2
04A6:  BSF    5A.7
04A7:  MOVF   56,W
04A8:  MOVWF  53
04A9:  BSF    53.7
04AA:  MOVF   53,W
04AB:  ADDWF  78,F
04AC:  BTFSC  03.0
04AD:  BSF    5A.7
04AE:  RLF    5A,F
04AF:  RRF    78,F
04B0:  RRF    79,F
04B1:  RRF    7A,F
04B2:  RRF    5D,F
04B3:  RRF    5C,F
04B4:  RRF    5B,F
04B5:  BCF    03.0
04B6:  DECFSZ 59,F
04B7:  GOTO   493
04B8:  MOVLW  01
04B9:  ADDWF  77,F
04BA:  BTFSC  03.0
04BB:  GOTO   4E0
04BC:  BTFSC  78.7
04BD:  GOTO   4C5
04BE:  RLF    5D,F
04BF:  RLF    7A,F
04C0:  RLF    79,F
04C1:  RLF    78,F
04C2:  DECF   77,F
04C3:  BTFSC  03.2
04C4:  GOTO   4E0
04C5:  BTFSS  5D.7
04C6:  GOTO   4D6
04C7:  INCF   7A,F
04C8:  BTFSS  03.2
04C9:  GOTO   4D6
04CA:  INCF   79,F
04CB:  BTFSS  03.2
04CC:  GOTO   4D6
04CD:  INCF   78,F
04CE:  BTFSS  03.2
04CF:  GOTO   4D6
04D0:  RRF    78,F
04D1:  RRF    79,F
04D2:  RRF    7A,F
04D3:  INCF   77,F
04D4:  BTFSC  03.2
04D5:  GOTO   4E0
04D6:  MOVF   52,W
04D7:  MOVWF  5A
04D8:  MOVF   56,W
04D9:  XORWF  5A,F
04DA:  BTFSS  5A.7
04DB:  GOTO   4DE
04DC:  BSF    78.7
04DD:  GOTO   4E4
04DE:  BCF    78.7
04DF:  GOTO   4E4
04E0:  CLRF   77
04E1:  CLRF   78
04E2:  CLRF   79
04E3:  CLRF   7A
04E4:  MOVF   7A,W
04E5:  MOVWF  47
04E6:  MOVF   79,W
04E7:  MOVWF  46
04E8:  MOVF   78,W
04E9:  MOVWF  45
04EA:  MOVF   77,W
04EB:  MOVWF  44
04EC:  DECFSZ 4B,F
04ED:  GOTO   462
04EE:  MOVF   47,W
04EF:  MOVWF  54
04F0:  MOVF   46,W
04F1:  MOVWF  53
04F2:  MOVF   45,W
04F3:  MOVWF  52
04F4:  MOVF   44,W
04F5:  MOVWF  51
04F6:  MOVF   51,W
04F7:  SUBLW  B6
04F8:  MOVWF  51
04F9:  CLRF   7A
04FA:  MOVF   52,W
04FB:  MOVWF  55
04FC:  BSF    52.7
04FD:  BCF    03.0
04FE:  RRF    52,F
04FF:  RRF    53,F
0500:  RRF    54,F
0501:  RRF    7A,F
0502:  RRF    79,F
0503:  RRF    78,F
0504:  RRF    77,F
0505:  DECFSZ 51,F
0506:  GOTO   4FD
0507:  BTFSS  55.7
0508:  GOTO   514
0509:  COMF   77,F
050A:  COMF   78,F
050B:  COMF   79,F
050C:  COMF   7A,F
050D:  INCF   77,F
050E:  BTFSC  03.2
050F:  INCF   78,F
0510:  BTFSC  03.2
0511:  INCF   79,F
0512:  BTFSC  03.2
0513:  INCF   7A,F
0514:  MOVF   7A,W
0515:  MOVWF  47
0516:  MOVF   79,W
0517:  MOVWF  46
0518:  MOVF   78,W
0519:  MOVWF  45
051A:  MOVF   77,W
051B:  MOVWF  44
051C:  BTFSS  47.7
051D:  GOTO   52B
051E:  DECF   49,F
051F:  BSF    49.5
0520:  COMF   44,F
0521:  COMF   45,F
0522:  COMF   46,F
0523:  COMF   47,F
0524:  INCF   44,F
0525:  BTFSC  03.2
0526:  INCF   45,F
0527:  BTFSC  03.2
0528:  INCF   46,F
0529:  BTFSC  03.2
052A:  INCF   47,F
052B:  MOVLW  3B
052C:  MOVWF  50
052D:  MOVLW  9A
052E:  MOVWF  4F
052F:  MOVLW  CA
0530:  MOVWF  4E
0531:  CLRF   4D
0532:  MOVLW  0A
0533:  MOVWF  4B
0534:  MOVF   48,W
0535:  BTFSC  03.2
0536:  INCF   49,F
0537:  BSF    03.1
0538:  MOVLW  44
0539:  MOVWF  04
053A:  BCF    03.7
053B:  MOVF   47,W
053C:  MOVWF  54
053D:  MOVF   46,W
053E:  MOVWF  53
053F:  MOVF   45,W
0540:  MOVWF  52
0541:  MOVF   44,W
0542:  MOVWF  51
0543:  MOVF   50,W
0544:  MOVWF  58
0545:  MOVF   4F,W
0546:  MOVWF  57
0547:  MOVF   4E,W
0548:  MOVWF  56
0549:  MOVF   4D,W
054A:  MOVWF  55
054B:  CALL   40D
054C:  MOVF   78,W
054D:  MOVF   77,F
054E:  BTFSS  03.2
054F:  GOTO   563
0550:  INCF   48,W
0551:  SUBWF  4B,W
0552:  BTFSC  03.2
0553:  GOTO   563
0554:  MOVF   49,W
0555:  BTFSC  03.2
0556:  GOTO   565
0557:  ANDLW  0F
0558:  SUBWF  4B,W
0559:  BTFSC  03.2
055A:  GOTO   55D
055B:  BTFSC  03.0
055C:  GOTO   595
055D:  BTFSC  49.7
055E:  GOTO   595
055F:  BTFSC  49.6
0560:  GOTO   565
0561:  MOVLW  20
0562:  GOTO   591
0563:  MOVLW  20
0564:  ANDWF  49,F
0565:  BTFSS  49.5
0566:  GOTO   573
0567:  BCF    49.5
0568:  MOVF   48,W
0569:  BTFSS  03.2
056A:  DECF   49,F
056B:  MOVF   77,W
056C:  MOVWF  49
056D:  MOVLW  2D
056E:  MOVWF  51
056F:  CALL   38A
0570:  MOVF   49,W
0571:  MOVWF  77
0572:  CLRF   49
0573:  MOVF   48,W
0574:  SUBWF  4B,W
0575:  BTFSS  03.2
0576:  GOTO   581
0577:  MOVF   77,W
0578:  MOVWF  49
0579:  MOVLW  2E
057A:  MOVWF  51
057B:  CALL   38A
057C:  MOVF   49,W
057D:  MOVWF  77
057E:  MOVLW  20
057F:  ANDWF  49,F
0580:  MOVLW  00
0581:  MOVLW  30
0582:  BTFSS  49.5
0583:  GOTO   591
0584:  BCF    49.5
0585:  MOVF   48,W
0586:  BTFSS  03.2
0587:  DECF   49,F
0588:  MOVF   77,W
0589:  MOVWF  49
058A:  MOVLW  2D
058B:  MOVWF  51
058C:  CALL   38A
058D:  MOVF   49,W
058E:  MOVWF  77
058F:  CLRF   49
0590:  MOVLW  30
0591:  ADDWF  77,F
0592:  MOVF   77,W
0593:  MOVWF  51
0594:  CALL   38A
0595:  BCF    03.1
0596:  MOVF   50,W
0597:  MOVWF  54
0598:  MOVF   4F,W
0599:  MOVWF  53
059A:  MOVF   4E,W
059B:  MOVWF  52
059C:  MOVF   4D,W
059D:  MOVWF  51
059E:  CLRF   58
059F:  CLRF   57
05A0:  CLRF   56
05A1:  MOVLW  0A
05A2:  MOVWF  55
05A3:  CALL   40D
05A4:  MOVF   7A,W
05A5:  MOVWF  50
05A6:  MOVF   79,W
05A7:  MOVWF  4F
05A8:  MOVF   78,W
05A9:  MOVWF  4E
05AA:  MOVF   77,W
05AB:  MOVWF  4D
05AC:  DECFSZ 4B,F
05AD:  GOTO   537
05AE:  BCF    0A.3
05AF:  BCF    0A.4
05B0:  GOTO   64A (RETURN)
....................  
.................... #list 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0255:  MOVF   6F,W
0256:  MOVWF  71
0257:  MOVF   6E,W
0258:  MOVWF  70
0259:  MOVF   71,W
025A:  MOVWF  7A
025B:  MOVF   70,W
025C:  MOVWF  04
025D:  BCF    03.7
025E:  BTFSC  7A.0
025F:  BSF    03.7
0260:  MOVF   00,F
0261:  BTFSC  03.2
0262:  GOTO   267
0263:  INCF   70,F
0264:  BTFSC  03.2
0265:  INCF   71,F
0266:  GOTO   259
....................    return(sc - s); 
0267:  MOVF   6E,W
0268:  SUBWF  70,W
0269:  MOVWF  77
026A:  MOVF   71,W
026B:  MOVWF  7A
026C:  MOVF   6F,W
026D:  BTFSS  03.0
026E:  INCFSZ 6F,W
026F:  SUBWF  7A,F
0270:  MOVF   77,W
0271:  MOVWF  78
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
05ED:  BCF    03.6
05EE:  CLRF   20
05EF:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include<stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #fuses HS, NOWDT, NOPROTECT, NOLVP 
....................  
.................... #use delay(clock=20M) 
*
0096:  MOVLW  52
0097:  MOVWF  04
0098:  BCF    03.7
0099:  MOVF   00,W
009A:  BTFSC  03.2
009B:  GOTO   0A9
009C:  MOVLW  06
009D:  MOVWF  78
009E:  CLRF   77
009F:  DECFSZ 77,F
00A0:  GOTO   09F
00A1:  DECFSZ 78,F
00A2:  GOTO   09E
00A3:  MOVLW  7B
00A4:  MOVWF  77
00A5:  DECFSZ 77,F
00A6:  GOTO   0A5
00A7:  DECFSZ 00,F
00A8:  GOTO   09C
00A9:  RETURN
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7) 
.................... #use i2c(MASTER, SDA=PIN_C4, SCL=PIN_C3,SLOW, NOFORCE_SW) 
.................... //#include "i2c-lcd.c" 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
00C5:  MOVLW  0F
00C6:  BSF    03.5
00C7:  ANDWF  08,W
00C8:  IORLW  F0
00C9:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00CA:  BCF    03.5
00CB:  BSF    08.2
....................    delay_cycles(1); 
00CC:  NOP
....................    lcd_output_enable(1); 
00CD:  BSF    08.0
....................    delay_cycles(1); 
00CE:  NOP
....................    high = lcd_read_nibble(); 
00CF:  CALL   0B9
00D0:  MOVF   78,W
00D1:  MOVWF  59
....................        
....................    lcd_output_enable(0); 
00D2:  BCF    08.0
....................    delay_cycles(1); 
00D3:  NOP
....................    lcd_output_enable(1); 
00D4:  BSF    08.0
....................    delay_us(1); 
00D5:  GOTO   0D6
00D6:  GOTO   0D7
00D7:  NOP
....................    low = lcd_read_nibble(); 
00D8:  CALL   0B9
00D9:  MOVF   78,W
00DA:  MOVWF  58
....................        
....................    lcd_output_enable(0); 
00DB:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00DC:  MOVLW  0F
00DD:  BSF    03.5
00DE:  ANDWF  08,W
00DF:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00E0:  BCF    03.5
00E1:  SWAPF  59,W
00E2:  MOVWF  77
00E3:  MOVLW  F0
00E4:  ANDWF  77,F
00E5:  MOVF   77,W
00E6:  IORWF  58,W
00E7:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
00B9:  MOVF   08,W
00BA:  MOVWF  77
00BB:  SWAPF  08,W
00BC:  ANDLW  0F
00BD:  MOVWF  78
....................   #endif 
00BE:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
00AA:  SWAPF  59,W
00AB:  ANDLW  F0
00AC:  MOVWF  77
00AD:  MOVLW  0F
00AE:  ANDWF  08,W
00AF:  IORWF  77,W
00B0:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
00B1:  NOP
....................    lcd_output_enable(1); 
00B2:  BSF    08.0
....................    delay_us(2); 
00B3:  MOVLW  03
00B4:  MOVWF  77
00B5:  DECFSZ 77,F
00B6:  GOTO   0B5
....................    lcd_output_enable(0); 
00B7:  BCF    08.0
00B8:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00BF:  BSF    03.5
00C0:  BCF    08.0
....................    lcd_rs_tris(); 
00C1:  BCF    08.1
....................    lcd_rw_tris(); 
00C2:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00C3:  BCF    03.5
00C4:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
00E8:  MOVF   78,W
00E9:  MOVWF  58
00EA:  BTFSC  58.7
00EB:  GOTO   0C5
....................    lcd_output_rs(address); 
00EC:  BTFSS  56.0
00ED:  BCF    08.1
00EE:  BTFSC  56.0
00EF:  BSF    08.1
....................    delay_cycles(1); 
00F0:  NOP
....................    lcd_output_rw(0); 
00F1:  BCF    08.2
....................    delay_cycles(1); 
00F2:  NOP
....................    lcd_output_enable(0); 
00F3:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
00F4:  SWAPF  57,W
00F5:  MOVWF  58
00F6:  MOVLW  0F
00F7:  ANDWF  58,F
00F8:  MOVF   58,W
00F9:  MOVWF  59
00FA:  CALL   0AA
....................    lcd_send_nibble(n & 0xf); 
00FB:  MOVF   57,W
00FC:  ANDLW  0F
00FD:  MOVWF  58
00FE:  MOVWF  59
00FF:  CALL   0AA
0100:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0101:  MOVLW  28
0102:  MOVWF  45
0103:  MOVLW  0C
0104:  MOVWF  46
0105:  MOVLW  01
0106:  MOVWF  47
0107:  MOVLW  06
0108:  MOVWF  48
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0109:  BCF    08.0
....................    lcd_output_rs(0); 
010A:  BCF    08.1
....................    lcd_output_rw(0); 
010B:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
010C:  MOVLW  0F
010D:  BSF    03.5
010E:  ANDWF  08,W
010F:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
0110:  BCF    08.0
....................    lcd_rs_tris(); 
0111:  BCF    08.1
....................    lcd_rw_tris(); 
0112:  BCF    08.2
....................  #endif 
....................      
....................    delay_ms(15); 
0113:  MOVLW  0F
0114:  BCF    03.5
0115:  MOVWF  52
0116:  CALL   096
....................    for(i=1;i<=3;++i) 
0117:  MOVLW  01
0118:  MOVWF  44
0119:  MOVF   44,W
011A:  SUBLW  03
011B:  BTFSS  03.0
011C:  GOTO   125
....................    { 
....................        lcd_send_nibble(3); 
011D:  MOVLW  03
011E:  MOVWF  59
011F:  CALL   0AA
....................        delay_ms(5); 
0120:  MOVLW  05
0121:  MOVWF  52
0122:  CALL   096
0123:  INCF   44,F
0124:  GOTO   119
....................    } 
....................     
....................    lcd_send_nibble(2); 
0125:  MOVLW  02
0126:  MOVWF  59
0127:  CALL   0AA
....................    delay_ms(5); 
0128:  MOVLW  05
0129:  MOVWF  52
012A:  CALL   096
....................    for(i=0;i<=3;++i) 
012B:  CLRF   44
012C:  MOVF   44,W
012D:  SUBLW  03
012E:  BTFSS  03.0
012F:  GOTO   13C
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0130:  MOVLW  45
0131:  ADDWF  44,W
0132:  MOVWF  04
0133:  BCF    03.7
0134:  MOVF   00,W
0135:  MOVWF  49
0136:  CLRF   56
0137:  MOVF   49,W
0138:  MOVWF  57
0139:  CALL   0BF
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
013A:  INCF   44,F
013B:  GOTO   12C
013C:  BCF    0A.3
013D:  BCF    0A.4
013E:  GOTO   5F1 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0378:  DECFSZ 53,W
0379:  GOTO   37B
037A:  GOTO   37E
....................       address=LCD_LINE_TWO; 
037B:  MOVLW  40
037C:  MOVWF  54
037D:  GOTO   37F
....................    else 
....................       address=0; 
037E:  CLRF   54
....................       
....................    address+=x-1; 
037F:  MOVLW  01
0380:  SUBWF  52,W
0381:  ADDWF  54,F
....................    lcd_send_byte(0,0x80|address); 
0382:  MOVF   54,W
0383:  IORLW  80
0384:  MOVWF  55
0385:  CLRF   56
0386:  MOVF   55,W
0387:  MOVWF  57
0388:  CALL   0BF
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0389:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
038A:  MOVF   51,W
038B:  XORLW  07
038C:  BTFSC  03.2
038D:  GOTO   398
038E:  XORLW  0B
038F:  BTFSC  03.2
0390:  GOTO   39D
0391:  XORLW  06
0392:  BTFSC  03.2
0393:  GOTO   3A5
0394:  XORLW  02
0395:  BTFSC  03.2
0396:  GOTO   3AB
0397:  GOTO   3B0
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0398:  MOVLW  01
0399:  MOVWF  52
039A:  MOVWF  53
039B:  CALL   378
039C:  GOTO   3B5
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
039D:  CLRF   56
039E:  MOVLW  01
039F:  MOVWF  57
03A0:  CALL   0BF
....................                      delay_ms(2); 
03A1:  MOVLW  02
03A2:  MOVWF  52
03A3:  CALL   096
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
03A4:  GOTO   3B5
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
03A5:  MOVLW  01
03A6:  MOVWF  52
03A7:  MOVLW  02
03A8:  MOVWF  53
03A9:  CALL   378
03AA:  GOTO   3B5
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
03AB:  CLRF   56
03AC:  MOVLW  10
03AD:  MOVWF  57
03AE:  CALL   0BF
03AF:  GOTO   3B5
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
03B0:  MOVLW  01
03B1:  MOVWF  56
03B2:  MOVF   51,W
03B3:  MOVWF  57
03B4:  CALL   0BF
....................      #endif 
....................    } 
03B5:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... /* Definicion de constantes */ 
.................... #define MAX_LINE 1 // Maximo de lineas que el usuario puede ingresar a la terminal 
....................  
.................... /* Prototipo de funciones */ 
.................... void escribir_i2c(); 
.................... void obtenerTemperatura(); 
.................... void leerEntrada(char *comando); 
.................... int analizaOpcion(char *comando); 
.................... int comparaStrings(char str1[], char str2[]); 
....................  
.................... int8 contador = 0; //contador principal 
.................... int8 countAux = 0; //contador auxiliar 
.................... char getch(void); 
.................... float valor_temperatura = 0.0; 
....................  
.................... int comparaStrings(char str1[], char str2[]) { 
....................    for(int i = 0; i < strlen(str1); i++) { 
*
0250:  CLRF   6D
0251:  MOVF   6A,W
0252:  MOVWF  6F
0253:  MOVF   69,W
0254:  MOVWF  6E
*
0272:  MOVF   78,W
0273:  SUBWF  6D,W
0274:  BTFSC  03.0
0275:  GOTO   28D
....................       if(str1[i] != str2[i]) return 0; 
0276:  MOVF   6D,W
0277:  ADDWF  69,W
0278:  MOVWF  04
0279:  BCF    03.7
027A:  BTFSC  6A.0
027B:  BSF    03.7
027C:  MOVF   00,W
027D:  MOVWF  6E
027E:  MOVF   6D,W
027F:  ADDWF  6B,W
0280:  MOVWF  04
0281:  BCF    03.7
0282:  BTFSC  6C.0
0283:  BSF    03.7
0284:  MOVF   00,W
0285:  SUBWF  6E,W
0286:  BTFSC  03.2
0287:  GOTO   28B
0288:  MOVLW  00
0289:  MOVWF  78
028A:  GOTO   28F
028B:  INCF   6D,F
028C:  GOTO   251
....................    } 
....................    return 1; 
028D:  MOVLW  01
028E:  MOVWF  78
028F:  RETURN
.................... } 
.................... void obtenerTemperatura() { 
....................     set_adc_channel(0); 
*
0341:  MOVLW  00
0342:  MOVWF  78
0343:  MOVF   1F,W
0344:  ANDLW  C3
0345:  IORWF  78,W
0346:  MOVWF  1F
....................     delay_ms(10); 
0347:  MOVLW  0A
0348:  MOVWF  52
0349:  CALL   096
....................     valor_temperatura = read_adc()*2; 
034A:  BSF    1F.1
034B:  BTFSC  1F.1
034C:  GOTO   34B
034D:  BCF    03.0
034E:  RLF    1E,W
034F:  CLRF   45
0350:  MOVWF  44
*
036D:  MOVF   7A,W
036E:  MOVWF  2C
036F:  MOVF   79,W
0370:  MOVWF  2B
0371:  MOVF   78,W
0372:  MOVWF  2A
0373:  MOVF   77,W
0374:  MOVWF  29
0375:  BCF    0A.3
0376:  BCF    0A.4
0377:  GOTO   62F (RETURN)
.................... } 
....................  
.................... void escribir_i2c(){ 
....................    i2c_start(); 
....................    i2c_write(0x42); //Direcion del esclavo 
....................    i2c_write(contador); //El dato a escribir 
....................    i2c_stop(); 
.................... } 
....................  
.................... void leerEntrada(char *comando) { 
....................    char *ptr; 
....................    char ch; 
....................     
....................    ptr = comando; 
*
013F:  MOVF   45,W
0140:  MOVWF  47
0141:  MOVF   44,W
0142:  MOVWF  46
....................    printf("Ingrese comando: \n\r"); 
0143:  MOVLW  04
0144:  BSF    03.6
0145:  MOVWF  0D
0146:  MOVLW  00
0147:  MOVWF  0F
....................     
....................    while ((ch = getchar()) != '\r') {printf("%c", ch);*ptr++ = (char)ch;}  
*
019D:  BCF    03.6
019E:  BTFSS  0C.5
019F:  GOTO   19E
01A0:  MOVF   1A,W
01A1:  MOVWF  48
01A2:  SUBLW  0D
01A3:  BTFSC  03.2
01A4:  GOTO   1B6
01A5:  MOVF   48,W
01A6:  BTFSS  0C.4
01A7:  GOTO   1A6
01A8:  MOVWF  19
01A9:  MOVF   47,W
01AA:  MOVWF  7A
01AB:  MOVF   46,W
01AC:  INCF   46,F
01AD:  BTFSC  03.2
01AE:  INCF   47,F
01AF:  MOVWF  04
01B0:  BCF    03.7
01B1:  BTFSC  7A.0
01B2:  BSF    03.7
01B3:  MOVF   48,W
01B4:  MOVWF  00
01B5:  GOTO   19E
....................    printf("\n\r"); 
01B6:  MOVLW  0A
01B7:  BTFSS  0C.4
01B8:  GOTO   1B7
01B9:  MOVWF  19
01BA:  MOVLW  0D
01BB:  BTFSS  0C.4
01BC:  GOTO   1BB
01BD:  MOVWF  19
....................    *ptr++ = 0; 
01BE:  MOVF   47,W
01BF:  MOVWF  7A
01C0:  MOVF   46,W
01C1:  INCF   46,F
01C2:  BTFSC  03.2
01C3:  INCF   47,F
01C4:  MOVWF  04
01C5:  BCF    03.7
01C6:  BTFSC  7A.0
01C7:  BSF    03.7
01C8:  CLRF   00
....................     
....................    printf("The given string is : %s\n\r", comando); 
01C9:  MOVLW  0E
01CA:  BSF    03.6
01CB:  MOVWF  0D
01CC:  MOVLW  00
01CD:  MOVWF  0F
01CE:  BCF    03.0
01CF:  MOVLW  16
01D0:  BCF    03.6
01D1:  MOVWF  49
*
022A:  MOVF   44,W
022B:  MOVWF  04
022C:  BCF    03.7
022D:  BTFSC  45.0
022E:  BSF    03.7
*
0245:  MOVLW  0A
0246:  BTFSS  0C.4
0247:  GOTO   246
0248:  MOVWF  19
0249:  MOVLW  0D
024A:  BTFSS  0C.4
024B:  GOTO   24A
024C:  MOVWF  19
024D:  BCF    0A.3
024E:  BCF    0A.4
024F:  GOTO   610 (RETURN)
.................... } 
....................  
.................... int analizaOpcion(char *comando) { 
....................    char *temperaturaString = "temperatura",  
*
0290:  MOVLW  74
0291:  MOVWF  48
0292:  MOVLW  65
0293:  MOVWF  49
0294:  MOVLW  6D
0295:  MOVWF  4A
0296:  MOVLW  70
0297:  MOVWF  4B
0298:  MOVLW  65
0299:  MOVWF  4C
029A:  MOVLW  72
029B:  MOVWF  4D
029C:  MOVLW  61
029D:  MOVWF  4E
029E:  MOVLW  74
029F:  MOVWF  4F
02A0:  MOVLW  75
02A1:  MOVWF  50
02A2:  MOVLW  72
02A3:  MOVWF  51
02A4:  MOVLW  61
02A5:  MOVWF  52
02A6:  CLRF   53
02A7:  CLRF   47
02A8:  MOVLW  48
02A9:  MOVWF  46
....................         *pwm = "pwm",  
02AA:  MOVLW  70
02AB:  MOVWF  56
02AC:  MOVLW  77
02AD:  MOVWF  57
02AE:  MOVLW  6D
02AF:  MOVWF  58
02B0:  CLRF   59
02B1:  CLRF   55
02B2:  MOVLW  56
02B3:  MOVWF  54
....................         *motor = "motor",  
02B4:  MOVLW  6D
02B5:  MOVWF  5C
02B6:  MOVLW  6F
02B7:  MOVWF  5D
02B8:  MOVLW  74
02B9:  MOVWF  5E
02BA:  MOVLW  6F
02BB:  MOVWF  5F
02BC:  MOVLW  72
02BD:  MOVWF  60
02BE:  CLRF   61
02BF:  CLRF   5B
02C0:  MOVLW  5C
02C1:  MOVWF  5A
....................         *leds = "leds"; 
02C2:  MOVLW  6C
02C3:  MOVWF  64
02C4:  MOVLW  65
02C5:  MOVWF  65
02C6:  MOVLW  64
02C7:  MOVWF  66
02C8:  MOVLW  73
02C9:  MOVWF  67
02CA:  CLRF   68
02CB:  CLRF   63
02CC:  MOVLW  64
02CD:  MOVWF  62
....................     
....................    if(comparaStrings(comando, temperaturaString)) return 0; 
02CE:  MOVF   45,W
02CF:  MOVWF  6A
02D0:  MOVF   44,W
02D1:  MOVWF  69
02D2:  MOVF   47,W
02D3:  MOVWF  6C
02D4:  MOVF   46,W
02D5:  MOVWF  6B
02D6:  CALL   250
02D7:  MOVF   78,F
02D8:  BTFSC  03.2
02D9:  GOTO   2DE
02DA:  MOVLW  00
02DB:  MOVWF  78
02DC:  GOTO   30F
02DD:  GOTO   30D
....................    else if(comparaStrings(comando, pwm)) return 1; 
02DE:  MOVF   45,W
02DF:  MOVWF  6A
02E0:  MOVF   44,W
02E1:  MOVWF  69
02E2:  MOVF   55,W
02E3:  MOVWF  6C
02E4:  MOVF   54,W
02E5:  MOVWF  6B
02E6:  CALL   250
02E7:  MOVF   78,F
02E8:  BTFSC  03.2
02E9:  GOTO   2EE
02EA:  MOVLW  01
02EB:  MOVWF  78
02EC:  GOTO   30F
02ED:  GOTO   30D
....................    else if(comparaStrings(comando, motor)) return 2; 
02EE:  MOVF   45,W
02EF:  MOVWF  6A
02F0:  MOVF   44,W
02F1:  MOVWF  69
02F2:  MOVF   5B,W
02F3:  MOVWF  6C
02F4:  MOVF   5A,W
02F5:  MOVWF  6B
02F6:  CALL   250
02F7:  MOVF   78,F
02F8:  BTFSC  03.2
02F9:  GOTO   2FE
02FA:  MOVLW  02
02FB:  MOVWF  78
02FC:  GOTO   30F
02FD:  GOTO   30D
....................    else if(comparaStrings(comando, leds)) return 3;  
02FE:  MOVF   45,W
02FF:  MOVWF  6A
0300:  MOVF   44,W
0301:  MOVWF  69
0302:  MOVF   63,W
0303:  MOVWF  6C
0304:  MOVF   62,W
0305:  MOVWF  6B
0306:  CALL   250
0307:  MOVF   78,F
0308:  BTFSC  03.2
0309:  GOTO   30D
030A:  MOVLW  03
030B:  MOVWF  78
030C:  GOTO   30F
....................    
....................    return -1; 
030D:  MOVLW  FF
030E:  MOVWF  78
030F:  BCF    0A.3
0310:  BCF    0A.4
0311:  GOTO   614 (RETURN)
.................... } 
....................  
.................... /* Enviar al correo: moises.melendes@fi-b.unam.mx*/ 
.................... /* Asunto: Diagrama Proteus Grupo 4*/ 
.................... int main() { 
*
05B1:  MOVF   03,W
05B2:  ANDLW  1F
05B3:  MOVWF  03
05B4:  BSF    03.5
05B5:  BSF    03.6
05B6:  BSF    07.3
05B7:  MOVLW  08
05B8:  BCF    03.6
05B9:  MOVWF  19
05BA:  MOVLW  02
05BB:  MOVWF  1A
05BC:  MOVLW  A6
05BD:  MOVWF  18
05BE:  MOVLW  90
05BF:  BCF    03.5
05C0:  MOVWF  18
05C1:  MOVLW  FF
05C2:  MOVWF  26
05C3:  BSF    26.3
05C4:  MOVF   26,W
05C5:  BSF    03.5
05C6:  MOVWF  07
05C7:  BCF    03.5
05C8:  BSF    26.4
05C9:  MOVF   26,W
05CA:  BSF    03.5
05CB:  MOVWF  07
05CC:  MOVLW  31
05CD:  MOVWF  13
05CE:  MOVLW  28
05CF:  BCF    03.5
05D0:  MOVWF  14
05D1:  BSF    03.5
05D2:  BSF    14.7
05D3:  BCF    14.6
05D4:  BCF    03.5
05D5:  CLRF   27
05D6:  CLRF   28
05D7:  CLRF   2C
05D8:  CLRF   2B
05D9:  CLRF   2A
05DA:  CLRF   29
05DB:  CLRF   2E
05DC:  CLRF   2D
05DD:  BSF    03.5
05DE:  BSF    03.6
05DF:  MOVF   09,W
05E0:  ANDLW  C0
05E1:  MOVWF  09
05E2:  BCF    03.6
05E3:  BCF    1F.4
05E4:  BCF    1F.5
05E5:  MOVLW  00
05E6:  BSF    03.6
05E7:  MOVWF  08
05E8:  BCF    03.5
05E9:  CLRF   07
05EA:  CLRF   08
05EB:  CLRF   09
05EC:  BCF    03.7
....................    /* Configuracion */ 
....................     lcd_init(); 
*
05F0:  GOTO   101
....................     enable_interrupts(INT_RB); 
05F1:  BSF    0B.3
05F2:  MOVLW  FF
05F3:  BSF    03.5
05F4:  IORWF  16,F
....................     enable_interrupts(GLOBAL); 
05F5:  MOVLW  C0
05F6:  BCF    03.5
05F7:  IORWF  0B,F
....................     Setup_port_a(ALL_ANALOG); 
05F8:  BSF    03.5
05F9:  BSF    03.6
05FA:  MOVF   09,W
05FB:  ANDLW  C0
05FC:  IORLW  1F
05FD:  MOVWF  09
05FE:  BCF    03.6
05FF:  BCF    1F.4
0600:  BCF    1F.5
0601:  MOVLW  FF
0602:  BSF    03.6
0603:  MOVWF  08
....................     Setup_adc(ADC_CLOCK_INTERNAL); 
0604:  BCF    03.5
0605:  BCF    03.6
0606:  BSF    1F.6
0607:  BSF    1F.7
0608:  BSF    03.5
0609:  BCF    1F.7
060A:  BCF    03.5
060B:  BSF    1F.0
....................  
....................     while (TRUE) { 
....................        char comando[20]; 
....................        leerEntrada(&comando); 
060C:  CLRF   45
060D:  MOVLW  2F
060E:  MOVWF  44
060F:  GOTO   13F
....................        int opcion = analizaOpcion(comando); 
0610:  CLRF   45
0611:  MOVLW  2F
0612:  MOVWF  44
0613:  GOTO   290
0614:  MOVF   78,W
0615:  MOVWF  43
....................        switch (opcion) { 
0616:  MOVF   43,W
0617:  BTFSC  03.2
0618:  GOTO   623
0619:  XORLW  01
061A:  BTFSC  03.2
061B:  GOTO   624
061C:  XORLW  03
061D:  BTFSC  03.2
061E:  GOTO   625
061F:  XORLW  01
0620:  BTFSC  03.2
0621:  GOTO   626
0622:  GOTO   627
....................          case 0: 
....................             break; 
0623:  GOTO   62E
....................          case 1:  
....................             break; 
0624:  GOTO   62E
....................          case 2: 
....................             break; 
0625:  GOTO   62E
....................          case 3: 
....................             break; 
0626:  GOTO   62E
....................          default: 
....................             printf("Ups, intenta de nuevo un comando válido\n\rAlgunos comandos validos son:\n\r motor on, pwm=50, leds off, temperatura\n\r"); 
0627:  MOVLW  1C
0628:  BSF    03.6
0629:  MOVWF  0D
062A:  MOVLW  00
062B:  MOVWF  0F
062C:  BCF    03.6
062D:  GOTO   312
....................             break; 
....................         } 
....................         obtenerTemperatura(); 
062E:  GOTO   341
....................         lcd_gotoxy(0, 1); 
062F:  CLRF   52
0630:  MOVLW  01
0631:  MOVWF  53
0632:  CALL   378
....................         printf(lcd_putc, "Temp.: %f C\n\r", valor_temperatura); 
0633:  MOVLW  8F
0634:  BSF    03.6
0635:  MOVWF  0D
0636:  MOVLW  00
0637:  MOVWF  0F
0638:  BCF    03.0
0639:  MOVLW  07
063A:  BCF    03.6
063B:  MOVWF  44
063C:  CALL   3B6
063D:  MOVLW  89
063E:  MOVWF  04
063F:  MOVF   2C,W
0640:  MOVWF  47
0641:  MOVF   2B,W
0642:  MOVWF  46
0643:  MOVF   2A,W
0644:  MOVWF  45
0645:  MOVF   29,W
0646:  MOVWF  44
0647:  MOVLW  02
0648:  MOVWF  48
0649:  GOTO   45C
064A:  MOVLW  93
064B:  BSF    03.6
064C:  MOVWF  0D
064D:  MOVLW  00
064E:  MOVWF  0F
064F:  BSF    03.0
0650:  MOVLW  04
0651:  BCF    03.6
0652:  MOVWF  44
0653:  CALL   3B6
....................         delay_ms(200); 
0654:  MOVLW  C8
0655:  MOVWF  52
0656:  CALL   096
0657:  GOTO   60C
....................     } 
....................    /* 
....................    lcd_init(0x4E, 16, 2); 
....................    while(true) { 
....................       //Elige la posicion de escritura  
....................       lcd_gotoxy(0,2); 
....................       //Imprime el contador 
....................       printf(lcd_putc,"Contador = %d", contador); 
....................       //Escribe el numero por i2c 
....................       escribir_i2c(); 
....................       //Escribe el numero en el puerto b 
....................       output_d(contador); 
....................       delay_ms(500); 
....................       //Aumenta los contadores 
....................       contador++; 
....................       countAux++; 
....................       //Si se cuenta hasta 10, se aplica un corrimiento  
....................       //a la suma principal 
....................       if(countAux == 10){ 
....................          countAux = 0; 
....................          contador += 6 ; 
....................       } 
....................    } 
....................    */ 
....................     
....................  
....................      
....................    return 0; 
0658:  MOVLW  00
0659:  MOVWF  78
.................... } 
....................  
065A:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
